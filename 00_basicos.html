<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fundamentos JavaScript</title>
</head>

<body>
  <h1>Fundamentos JavaScript</h1>
  <script>
    /* **********     Curso JavaScript: 3. Variables: var 游볡VS游볡 let - #jonmircha     ********** */

    /* var hola = "Hola Mundo";
    let hello = "Hello World";
    console.log(hola);
    console.log(hello);
    console.log(window);
    console.log(window.hola);
    console.log(window.hello); */
    //Ambito de bloque
    //Esto es un bloque - comentario de una lines
    /*
    Esto
    es
    un
    comentario
    de
    varias
    l칤neas */
    /* console.log ("****************var*****************");
    var musica = "Rock";
    console.log("Variable M칰sica antes del Bloque", musica);
    {
      var musica = "Pop";
      console.log("Variable M칰sica dentro del Bloque", musica);
    }
    console.log("Variable M칰sica despu칠s del Bloque", musica);
    console.log("****************let*****************");
    let musica2 = "Rock";
    console.log("Variable M칰sica antes del Bloque", musica2);
    {
      let musica2 = "Pop";
      console.log("Variable M칰sica dentro del Bloque", musica2);
    }
    console.log("Variable M칰sica despu칠s del Bloque", musica2); */





    /* **********     Curso JavaScript: 4. Constantes (const) - #jonmircha     ********** */

    /*  let a;
     const PI = 3.1416;
     //const NUEVE;
     console.log(PI);
     //PI = 3.15;

     a = "kenai";
     console.log(a);

     const objeto = {
       nombre: "Jon",
       edad: 35
     }

     const colores = ["blanco", "negro", "azul"];

     console.log(objeto);
     console.log(colores);

     objeto.correo = "jonmircha@gmail.com";
     colores.push("anaranjado");

     console.log(objeto);
     console.log(colores); */





    /* **********     Curso JavaScript: 5. Cadenas de Texto (Strings) - #jonmircha     ********** */

    /*
        //Cadenas de Texto aka Strings
        let nombre = "Jon";
        let apellido = 'MirCha';
        let saludo = new String("Hola Mundo"); -> es una manera de declarar una cadena de texto es con su constructor o
        sea con el objeto string. La palabra new String: la palabra reservada new es un operador, que me va permitir
        crear un objeto nuevo de un cierto tipo de dato, en este caso como le colocamos String, me va crear una cadena
        de texto(nadie utiliza esta forma, ya que es mas practico utilizar los " " ' ').
        let lorem = "       Lorem ipsum, dolor sit amet consectetur adipisicing elit. Est, et dolorum. Adipisci sequi, voluptates accusamus earum magnam non pariatur odit consequuntur dicta modi. Quam soluta aliquid nam ea quod dolore.      ";

        console.log(nombre, apellido, saludo);
        console.log(
          nombre.length,
          apellido.length,
          saludo.length,
          nombre.toUpperCase(),     toUpperCase ->es un metodo para que todas las palabras se escriban en MAYUSCULA
          apellido.toLowerCase(),   toLowerCase ->es un metodo para que todas las palabras se escriban en MINUSCULA
          lorem.includes("amet"),   includes  ->es para verificar si en la variable lorem se incluye la palabra amet
          lorem.includes("jon"),     
          lorem,
          lorem.trim(),             trim  ->saca los "espacios en blanco que estan al principio y al final de lorem
          lorem.split(" "),         
          lorem.split(",")          split  ->convierte la cadena de texto en un arreglo(por ejemplo si entrecomillas
          tiene un espacio en blanco va a armar el arreglo separando la cadena de texto por los espacios en blanco
          o sea va a seperar cada vez que encuentre un espacio en blanco; en cambio si tiene la coma significa que va 
          a seperar la cadena de texto hasta donde haya una coma)
        );

     */





    /* **********     Curso JavaScript: 6. Template Strings - #jonmircha     ********** */

    /* let nombre = "Jon";
    let apellido = "MirCha";
 
    //Concatenaci칩n
    //let saludo = "Hola mi nombre es " + nombre + " " + apellido + ".";
    //console.log(saludo);

    //Interpolci칩n de variables
    //Template String
    /* let saludo2 = `Hola mi nombre es ${nombre} ${apellido}.`;
    console.log(saludo2);

    let ul = "<ul>< li > Primavera</li><li>Verano</li><li>Oto침o</li><li>Invierno</li></ul > ";

    console.log(ul);

    let ul2 = `
      <ul>
        <li>Primavera</li>
        <li>Verano</li>
        <li>Oto침o</li>
        <li>Invierno</li>
    </ul>
    `;

    console.log(ul2);

    let ul3 = "<ul>";
    ul3 += "<li> Primavera</li>";
    ul3 += "<li>Verano</li>";
    ul3 += "<li>Oto침o</li>";
    ul3 += "<li>Invierno</li>";
    ul3 += "</ul>";

    console.log(ul3);
 */





    /* **********     Curso JavaScript: 7. N칰meros (Numbers) - #jonmircha     ********** */

    /* let a = 2;
    let b = new Number(1);  la palabra reservada new es un operador, que me va permitir crear un objeto nuevo de un cierto tipo de dato, en este caso como le colocamos Number y crea un numero.
    let c = 7.19;
    let d = "5.6";

    console.log(a, b);
    console.log(c.toFixed(1));    toFixed ->dice cuantos numeros DECIMALES va a tener el numero.  //7.2
    console.log(c.toFixed(5));                                                                    //7.19000
    console.log(parseInt(c));     parseInt ->el metodo devuelve la parte entera del numero        //7
    console.log(parseFloat(c));   parseFloat ->devuelve la parte entera y la parte decimal de un numero   //7.19
    console.log(typeof c, typeof d);    type of ->te dice que tipo de dato es la variable  //number string
    console.log(a + b);           //3
    console.log(c + parseInt(d));       ->para hacer la suma de numero mas cadena de texto que es un numero, le coloco
    el parseInt, pero en este caso suma la parte entera unicamente; abajo utilizamos parseFloat por el cual me hace la suma correctamente (7.19 + '5.6') osea suma el numero mas la cadena de texto que es un numero, suma la parte 
    entera y la parte decimal.
    console.log(c + parseFloat(d));
    esta es otra forma de hacerlo, poner el Number adelante del parse:
    console.log(c + Number.parseInt(d));    
    console.log(c + Number.parseFloat(d)); */





    /* **********     Curso JavaScript: 8. Booleans - #jonmircha     ********** */

    /* let verdadero = true;
    let falso = false;
    let v = Boolean(true);
    let f = Boolean(false);

    console.log(verdadero, falso, v, f);
    console.log(typeof verdadero, typeof falso);   -> te dice que es un tipo de dato Boolean(booleano)
    console.log(Boolean(0));
    console.log(Boolean(-7));
    console.log(Boolean(""));
    console.log(Boolean(" ")); */





    /* **********     Curso JavaScript: 9. undefined, null & NaN - #jonmircha     ********** */

    //undefined indica que no se ha inicializado una variable y que el valor est치 ausente
    /* let indefinida;
    console.log(indefinida); 

    //null es un valor especial que indica la ausencia de un valor
     let nulo = null;
    console.log(null); 

    //NaN - Not a Number
     let noEsUnNumero = "hola" * 3.7;
    console.log(noEsUnNumero); */




    /* **********     Curso JavaScript: 10. Funciones - #jonmircha     ********** */

    /*
    Una funci칩n es un bloque de c칩digo, autocontenido, que se puede definir una vez y ejecutar en cualquier momento. Opcionalmente, una funci칩n puede aceptar par치metros y devolver un valor.

    Las funciones en JavaScript son objetos, un tipo especial de objetos:

    Se dice que las funciones son ciudadanos de primera clase porque pueden asignarse a un valor, y pueden pasarse como argumentos y usarse como un valor de retorno.
    

    //Declaraci칩n de funci칩n
      function estoEsUnaFuncion() {             ->empieza la funcion
       console.log("Uno");
       console.log("Dos");                        ->lo que esta entre llaves({}) es el codigo a ejecutarse
       console.log("Tres");
     }

    //Invocaci칩n de funci칩n
    estoEsUnaFuncion();
    estoEsUnaFuncion();
    estoEsUnaFuncion();
    estoEsUnaFuncion(); 

    function unaFuncionQueDevuelveValor() {
      console.log("Uno");
      return 19;
      console.log("Dos");
      console.log("Tres");
      return "La funci칩n ha retornado una Cadena de texto";
    } 

    //let valorDeFuncion = unaFuncionQueDevuelveValor();

    //console.log(valorDeFuncion);    //Uno  19

    en la funcion unaFuncionQueDevuelveValor ->cuando el interprete encuentre la palabra reservada RETURN, 
    automaticamente deja de leer las lineas de codigo que estan debajo de esa palabra reservada, por ese motivo
    cuando hago el console.log(valorDeFuncion) me devuelve Uno 19, porque despues de retornar el 19, no lee las
    otras lineas de codigo, las ignora.
    
    function saludar(nombre = "Desconocido", edad = 0) {
       console.log(`Hola mi nombre es ${nombre} y tengo ${edad} a침os.`);
     } 

    //saludar("kEnAi", 7);
    //saludar();

    //Funciones declaradas VS funciones expresadas

    funcionDeclarada();  ->si yo invoco la funcion declarativa antes de su definicion, no pasa nada, me invoca la 
    funcion igualmente, a eso le llamamos HOISTING(como que 'sube' la funcion arriba de la invocacion, lo hace 
    automaticamente JS), en resumen no importa donde invoque la funcion porque el interprete la va invocar igual 

     function funcionDeclarada() {
      console.log("Esto es un funci칩n declarada, puede invocarse en cualquier parte de nuestro c칩digo, incluso antes de que la funci칩n sea declarada");
    } 

    funcionDeclarada();
    
    funcionExpresada();  ->si yo invoco la funcion anonima o expresiva antes de su definicion me va tirar un error,
    por lo tanto no puedo invocarla en cualquier lugar o antes de declarar la funcion porque me tira un error('no 
    puedes invocar la funcion porque no fue declarada, porque la estas invocando antes de su inicializacion')

    //funci칩n an칩nima (no tiene nombre) o funcion expresada(la estamos asignando como valor a una variable)
     const funcionExpresada = function () {
      console.log("Esto es una funci칩n expresada, es decir, una funci칩n que se le ha asignado como valor a una variable, si invocamos esta funci칩n antes de su definici칩n JS nos dir치 'Cannot access 'funcionExpresada' before initialization'")
    } 

    //funcionExpresada();
    */




    /* **********     Curso JavaScript: 11. Arreglos (Arrays) - #jonmircha     ********** */

    /*     const a = [];
        const b = [1, true, "Hola", ["A", "B", "C", [1, 2, 3]]];
        console.log(a);
        console.log(b);
        console.log(b.length);
        console.log(b[2]);
        console.log(b[0]);
        console.log(b[3]);
        console.log(b[3][2]);
        console.log(b[3][3][0]);

        const c = Array.of("X", "Y", "Z", 9, 8, 7);  

        const d = Array(100).fill(false);      ->Array(n).fill('algo') donde n quiere decir cuantas posiciones tiene 
        el arreglo y lo que esta adentro de fill quiere decir el tipo de dato q va contener ese arreglo. En este caso hice un arreglo de 100 posiciones que tengan el valor booleano false.

        console.log(d);

        const e = new Array();      ->la palabra reservada new es un operador, que me va permitir crear un objeto
        nuevo de un cierto tipo de dato, en este caso como le colocamos Array, me va crear un arreglo

        console.log(c);
        console.log(e);

        const f = new Array(1, 2, 3, true, false);
        console.log(f);

        const colores = ["Rojo", "Verde", "Azul"];
        console.log(colores);

        colores.push("Negro");     ->push agrega al final del arreglo el valor negro(en este caso) al arreglo colores
        console.log(colores);

        colores.pop();             ->pop elimina el ultimo elemento de arreglo colores
        console.log(colores);

        colores.forEach(function (el, index) {
          console.log(`<li id="${index}">${el}</li>`);
        });                                                 

        el forEach nos permite ejecutar una funcion por cada uno de los elementos que tenga el arreglo. Por ejemplo
        en este ejemplo el significa elemento, mientras que index es el numero de indice del elemento. Con el forEach
        lo que hacemos en si es recorrer el elemento. El resultado seria: 
        <li id="0">Rojo</li>
        <li id="1">Verde</li>
        <li id="2">Azul</li>
        
        */





    /* **********     Curso JavaScript: 12. Objetos - #jonmircha     ********** */

    /* let a = new String("Hola");
    //console.log(a)

    const b = {}
    console.log(b);

    const c = new Object(); la palabra reservada new es un operador, que me va permitir crear un objeto nuevo de un
    cierto tipo de dato, en este caso como le colocamos el prototipo Object, me va crear un objeto
 
    un objeto es una coleccion de llaves:valores(key:value) y se separan con acento.Puede contener cualquier 
    tipo de dato.
     dentro de un objeto a las variables se le van a llamar atributos/propiedades(nombrem apellido, edad, 
     pasatiempos, soltero,contacto) y a las funciones se les llama m칠todos(saludar, decirMiNombre) 
        const jon = {
          nombre: "Jon",
          apellido: "MirCha",
          edad: 35,
          pasatiempos: ["Correr", "Hacer ejercicio", "Dar clases"],
          soltero: false,
          contacto: {
            email: "jonmircha@gmail.com",
            twitter: "@jonmircha",
            movil: "5215512345678"
          },
          saludar: function () {
            console.log(`Hola :)`)
          },
          decirMiNombre: function () {
            console.log(`Hola me llamo ${this.nombre} ${this.apellido} y tengo ${this.edad} a침os y me puedes seguir como ${this.contacto.twitter} en twitter.`)   //this hace referencia al objeto donde se esta trabajando,
            por ejemplo si ponemos this.nombre, si nombre cambia, en la funcion tambien cambia
          }
        }
             ACCEDIENDO AL OBJETO: con corchete o con punto(es la forma mas utilizada y se recomienda utilizar punto)
        console.log(jon);    //imprime todos elementos del objeto
        console.log(jon["nombre"]);    //accedo con corchete,imprime el nombre
        console.log(jon["apellido"]);  //accedo con corchete, imprime el apellido
        console.log(jon.nombre);       //accedo con punto, imprime el nombre
        console.log(jon.apellido);     //accedo con punto, imprime apellido
        console.log(jon.edad);      
        console.log(jon.soltero);
        console.log(jon.pasatiempos);   //me va imprimir el arreglo completo
        console.log(jon.pasatiempos[1]);    //como pasatiempos es un arreglo, accedo al arreglo con corchete e imprimo 
        el elemento 1(hacer ejercicios)
        console.log(jon.contacto);       //me va imprimir el objeto completo
        console.log(jon.contacto.twitter);       //como es un objeto utlizo la forma de acceder del punto, accedo al 
        elemento del objeto TWITTER
        jon.saludar();   //invoco la funcion que esta dentro del objeto jon
        jon.decirMiNombre();

        console.log(Object.keys(jon));     //Object.keys imprime en un arreglo las llaves(nombre,apellido, edad, pasatiempos, soltero, contacto, saludar, decirMiNombre)
        console.log(Object.values(jon));   //Object.values imprime en un arreglo los valores(jon,mircha,etc)
        console.log(jon.hasOwnProperty("nombre"));   //me permite saber si un objeto tiene esa propiedad, o sea que si un objeto tiene el nombre de la propiedad que le paso; me devuelve true o false. En este caso me devuelve true
        console.log(jon.hasOwnProperty("nacimiento"));  //false
     */





    /* **********     Curso JavaScript: 13. Tipos de Operadores - #jonmircha     ********** */

    /* OPERADORES:
    
    Aritm칠ticos:  + - * / % ()  

    let a = 5 + (5 - 10) * 3;
    let modulo = 5 % 2;

    console.log(a);
    console.log(modulo);
 

     Relacionales: >, <,   >=, <=, ==, ===, !=, !== 

     console.log(8 > 9);
    console.log(9 > 8);
    console.log(8 >= 9);
    console.log(9 >= 8);
    console.log(7 < 7);
    console.log(7 <= 7); 

    
    = 1 igual es asignaci칩n  de variable
    == 2 iguales es comparacion de valores
    === 3 igulaes es comparaci칩n de tipo de dato y de valor
    

    console.log(7 == 7);
    console.log("7" == 7);
    console.log(0 == false);

    console.log(7 === 7);
    console.log("7" === 7);
    console.log(0 === false); 

   Incremento Decremento 
     let i = 2;

    console.log(i++);   //2    pero pasa a 3
    console.log(++i);   //4     (3 y le sumo uno)
    

    //i = i + 2;  //3
    //i += 2;     //3
    //i *=3;      //9


    //operador unario
    i++;    cuando vamos de uno en uno, suma uno
    i--;       cuando vamos de uno en uno, restamos uno
    ++i;       es lo mismo pero cambia la posicion de los signos
    --i;       es lo mismo pero cambia la posicion de los signos
    console.log(i); 

   
    L칩gicos
      ! - Not : Niega, es decir lo que es verdadero lo vuelve falso y viceversa
      || - Or: Cuando tengo 2 o m치s condiciones, con que una se cumpla, es decir sea verdadera, el OR ser치 verdadero.
      && - And: Cuando tengo 2 o m치s condiciones, todas tienen que cumplirse, es decir ser verdaderas, para que AND se valide 
    
    console.log(!true);
    console.log(!false);
    console.log((9 === 9) || ("9" === 9));
    console.log((9 === 9) && ("9" === 9));
    console.log((9 === 9) && ("9" === "9")); */





    /* **********     Curso JavaScript: 14. Condicionales - #jonmircha     ********** */

    /*
     IF - ELSE
    
    let edad = 9;

    if (edad > 17) {
      console.log("Eres mayor de Edad");
    } else {
      console.log("Eres menor de Edad");
    }

    if (edad >= 18) {
      console.log("Eres mayor de Edad");
    } else {
      console.log("Eres menor de Edad");
    }

    if (edad < 18) {
      console.log("Eres menor de Edad");
    } else {
      console.log("Eres mayor de Edad");
    }

    if (edad <= 17) {
      console.log("Eres menor de Edad");
    } else {
      console.log("Eres mayor de Edad");
    } 
    
    
    
    IF - ELSE IF - ELSE
      D칠jame Dormir - 0hrs - 5hrs
      Buenos dias 6hrs - 11hrs
      Buenas tardes 12hrs - 18hrs
      Buenas noches 19hrs - 23hrs
    
    
    let hora = 23;
    if (hora >= 0 && hora <= 5) {
      console.log("D칠jame dormir");
    } else if (hora >= 6 && hora <= 11) {
      console.log("Buenos d칤as");
    } else if (hora >= 12 && hora <= 18) {
      console.log("Buenas tardes");
    } else {
      console.log("Buenas noches");
    }

    if (hora < 6) {
      console.log("D칠jame dormir");
    } else if (hora > 5 && hora < 12) {
      console.log("Buenos d칤as");
    } else if (hora > 11 && hora < 19) {
      console.log("Buenas tardes");
    } else {
      console.log("Buenas noches");
    } 
    
    
    OPERADOR TERNARIO (condici칩n) ? verdadero : falsa 
      console.log("Operador Ternario");

    podemos poner todo junto (condicion,verdadero y falso) o ser mas ordenado y dejarlo en
    lineas separadas:
     let eresMayor = (edad >= 18)
       ? "Eres mayor de Edad"
       : "Eres menor de Edad";
     console.log(eresMayor); 

    SWITCH -CASE
    
    domingo -0
    lunes - 1
    martes - 2
    mi칠rcoles - 3
    jueves - 4
    viernes - 5
    s치bado - 6
    
    
    
    let dia = 2;

    switch (dia) {
      case 0:
        console.log("Domingo");
        break;
      case 1:
        console.log("Lunes");
        break;
      case 2:
        console.log("Martes");
        break;
      case 3:
        console.log("Mi칠rcoles");
        break;
      case 4:
        console.log("Jueves");
        break;
      case 5:
        console.log("Viernes");
        break;
      case 6:
        console.log("S치bado");
        break;
      default:
        console.log("El d칤a no existe");
        break;
    }
    el break le quiere decir al lenguaje de programacion que cuando este en un caso y lea todo el codigo y si no se 
    cumple el caso, que salga de ese caso y pase al siguiente. Si omitimos el break el switch lee directamente todos los casos
    el default quiere decir que si no se cumple ninguno de esos casos, o sea que el caso sea uno particular
    y no corresponda a los casos de arriba, entonces correra esa linea de codigo(por ejemplo se va a imprimir
    el dia no existe)
 */


    /* **********     Curso JavaScript: 15. Ciclos (Loops) - #jonmircha     ********** */

    /*  let contador = 0;

     while (contador < 10) {
       console.log("while " + contador);
       contador++;
     }

     mientras(while) contador sea menor que 10, imprime while + contador, y para que no sea un loop infinito
     (o sea que contador no valga 0 siempre e imprima while 0 infinitamente) vamos a incrementar el contador a 1.
     Entonces queria : while 0, while 1, while 2, while 3, while 4, while 4, while 5, while 6, while 7, 
     while 8, while 9, y en el momento que llegaria el while 10 la condicion no se cumple, por lo tanto no entra.
     En resumen, lo que hace el while es que primero se fija si cumple la condicion y luego ejecuta el codigo
     que esta dentro.

     do {
       console.log("do while " + contador);
       contador++;
     } while (contador < 10); 
     
     el do while lo que hace es primero ejecutar el codigo (console.log...) y luego se fija que cumpla la condicion
     en este caso el ejemplo quedaria:  do while 0, do while..., do while 9.
     La diferencia con el while es que si por ejemplo nosotros cambiamos el contador a 10, en el do while se va 
     a imprimir POR LO MENOS UNA VEZ (quedaria do while 10), en cambio con el while como primero se fija si se 
     cumple la condicion por lo tanto como la condicion no se cumple, entonces no se imprime nada.
     EN RESUMEN con do while siempre se va imprimir por lo menos una vez ya que analiza la condicion luego de 
     ejecutar el codigo, y con while no se va imprimir si no se cumple la condicion, ya que primero analiza
     la condicion y luego ejecuta el codigo.
     
     
    for (inicializaci칩n de variable; condici칩n; decremento o incremento) {
      sentencias que ejecuta el for
      sentencias que ejecuta el for
      sentencias que ejecuta el for
    } 
    
    
    for (let i = 0; i < 10; i++) {
      console.log("for " + i);
    }                              //for 0, for 2, for 3, for 4, for 5, for 6, for 7, for 8, for 9

    let numeros = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

    for (let i = 0; i < numeros.length; i++) {
      console.log(numeros[i]);
    }                               //10, 20, 30, 40, 50, 60, 70, 80, 90, 100

    esto sirve para RECORRER arreglos(como el forEach)
    En este caso puse que la i sea menor que el largo del arreglo, por lo tanto va imprimir todos los elementos del
    arreglo, en cambio si ponia que i<5  se iba a imprimir: 10, 20, 30, 40, 50 (de la posicion 0 a la 4, ya que la
    posicion 5 no cumple con la condicion, o sea que la posicion 5 es igual a 5 y no menor que 5)

    FORIN, FOROF: La diferencia de los dos es que for in nos permite recorrer solamente las propiedades de un 
    objeto, en cambio con el for of me va permitir recorrer todos los elementos de cualquier objeto que sea 
    iterable en JS(arreglos, cadenas de texto)


    -FOR IN  
     for (const key in object) {
        
      }

    -FOR OF ->
    for (const iterator of object) {
      
    }

    const jon = {
      nombre: "Jon",
      apellido: "MirCha",
      edad: 35
    }

    for (const propiedad in jon) {
      console.log(propiedad);
    }         //vamos a recorrer las propiedades del objeto JON,va imprimir las propiedades, por lo tanto
    lo que imprime es: nombre, apellido, edad (solo los nombres de las propiedades) lo que me permite recorrer
    o iterar todas las propiedades del objeto jon.


    for (const propiedad in jon) {
      console.log(`Key: ${propiedad}, Value: ${jon[propiedad]}`);
    }        //vamos a recorrer las propiedades del objeto JON, y en este caso lo que hago es imprimir las 
    propiedades y los valores de dichas propiedades. En el objeto jon, imprimir la propiedad como lo hicimos 
    anteriormente, al momento de imprimir el valor tengo dos opciones jon.propiedad o jon[propiedad]. En este caso 
    vamos a utlizar la opcion de los corchetes ya que cuando trabajamos con el for in y utlizamos el punto nos va 
    salir undefined en ves del valor, en cambio si utlizamos corchetes salen los valores.
    Lo que imprime es: Key:nombre ,Value:"Jon" ; Key:apellido ,Value:췅MirCha"  Key:edad ,Value: 35


    for (const elemento of numeros) {
      console.log(elemento);
    }          //aca vamos a recorrer los elementos del arreglo NUMEROS, por lo que imprime los elementos del
    arreglo de numeros. Lo que imprime es: 10,20,30,40,50,60,70,80,90,100

    let cadena = "Hola Mundo";

    for (const caracter of cadena) {
      console.log(caracter);   //aca vamos a recorrer los caracteres de la varible cadena, me va imprimir los 
      caracteres incluyendo los espacio. Lo que imprime es: H,o,l,a, ,M,u,n,d,o
    } */


    /* **********     Curso JavaScript: 16. Manejo de Errores - #jonmircha     ********** */
    /*  try {
       console.log("En el Try se agrega el c칩digo a evaluar");     aca se pone el cod a evaluar
       noExiste;
       console.log("Segundo mensaje en el try");
     } catch (error) {
       console.log("Catch, captura cualquier error surgido o lanzado en el try");  si el cod a evaluar tiene un error 
       se imprime lo q esta dentro del console.log
       console.log(error); (con esta opcion puedo hacer que me imprima el error en la consola)
     } finally {
       console.log("El bloque finally se ejecutar치 siempre al final de unbloque try-catch");
     }

     el codigo quedaria(primero se imprime el primer conselo.log, luego se imprime catch q encontro un error, luego se 
     imprime que error encontro, y finalmente se imprime el finally; el segundo console.log no se imprime ya que
     antes de ese console.log esta el error, y cuando la consola encuentra ese error todo lo que esta abajo no se
     evalua):
     -En el Try se agrega el codigo a evaluar (porque no hay error en el console.log)
     -Catch, captura cualquier error surgido o lanzado en el try(porque llame una variable que no esta declarada 
     noExiste, por lo tanto hay un error y el catch captura el error)
     -Reference error: noExiste is not defined ...
     -El bloque finally se ejecutara siempre al final de unbloque try-catch (el bloque finally siempre se va ejecutar)

     Cuando el Catch detecta el error(en este caso la variable no declarada) todo el codigo que esta debajo de ese
     error no se lee directamente. Por ejemplo si ponemos la variable debajo de 'Segundo mensaje en el try' el 
     codigo que se imprime en la consola seria diferente:
     -En el Try se agrega el codigo a evaluar
     -Segundo mensaje en el try
     -Catch, captura cualquier surgido en el try
     -Reference error: noExiste is not defined...
     -El bloque finally se ejecutara siempre al final de unbloque try-catch

     Primero se imprimen los dos console.log, luego se imprime el catch q encontro un error, luego se imprime
     que error encontro y finalmente se imprime el finally.




     try {
       let numero = "y";

       if (isNaN(numero)) {
         throw new Error("El caract칠r introducido no es un N칰mero");
       }

       console.log(numero * numero);
     } catch (error) {
       console.log(`Se produjo el siguiente error: ${error}`);
     } 
     
     En este caso lo que hacemos es comprobar que una variable tenga el tipo de dato numero, para que haga imprima
     numero*numero. Con isNaN verificamos que lo que le pasamos por parentesis sea un numero, si es un numero devuelve true si no es un numero devuelve false, en este caso podemos personalizar que nos va a salir en caso de que
     numero no sea un numero(personalizamos lo que va salir en el catch), ponemos la palabra reservada throw new 
     seguida del tipo de error(error de sintaxis, error semantico, etc) si no sabemos que tipo de error vamos a 
     utilizar simplemente defino un error general que seria Error, entonces quedaria : throw new Error + el mensaje que queremos pasarle en la consola al usuario para que sepa el error que esta cometiendo. En este caso le estamos 
     pidiendo el tipo de dato numero. Si la variable numero= 10, en la consola me va imprimir 10*10=100, no marca 
     errores porque 10 efectivamente en un numero. Pero como numero='y' es una string, la cual no cumple la condicion
     y directamente catch me toma el error, por lo cual me va imprimir:
     Se produjo el siguiente error: El caracter introducido no es un Numero.
     
     
     */


    /* **********     Curso JavaScript: 17. break & continue - #jonmircha     ********** */

    /*
    BREAK Y CONTINUE -> nos ayudan a controlar el flujo de nuestras estructuras de control, por ejemplo cuando
    necesitamos romper,saltar o salirnos de la estructura, etc.
    
    const numeros = [0, 1, 2, 3, 4, 5, 16, 7, 8, 9, 0];

    for (let i = 0; i < numeros.length; i++) {       
      if (i === 5) {          
        break;
      }
      console.log(numeros[i]);
    }
    
    En el ejemplo del break quiere decir que recorriendo el array numeros, cuando se cumpla la condicion se salga 
    del for. En este caso lo que hace es cuando se cumpla i=5 (o sea cuando i llege a la posicion 5), se salga
    del for, o sea se sale, se rompe la estructura en la que esta(el for). Lo que se va imprimir es: 0,1,2,3,4


    for (let i = 0; i < numeros.length; i++) {
      if (i === 6) {
        continue;
      }
      console.log(numeros[i]);
    } 
    
    
    En el ejemplo del continue, recorre el array numeros y cuando i este en la posicion 6(i=6) salta la 
    posicion 5. Lo que se va imprimir es 0,1,2,3,4,5,7,8,9,0 (la posicion 6=16 no se va a imprimir, porque la 
    salteo, la omito)
    
    */


    /* **********     Curso JavaScript: 18. Destructuraci칩n - #jonmircha     ********** */
    /*
    DESTRUCTURACION: es una nueva forma(ES6) de asignar valores sobre todo a arreglos y a objetos
    
    Vamos a verlo con arreglos: vamos a suponer que tengo un arreglo, y quiero guardar cada uno de los elementos
    en diferentes variables. Tenemos dos maneras de hacer sin destructuracion y con destructuracion.
    
    const numeros = [1, 2, 3];

    Aca lo que hacemos es guardar en variables independientes cada uno de los elementos del arreglo numeros
    //Sin destructuraci칩n
    let uno = numeros[0],
      dos = numeros[1],
      tres = numeros[2];

    console.log(uno, dos, tres);     //1 2 3

    Aca lo que hacemos es crear un arreglo[one, two, three], al cual le voy asignar el arreglo de numeros.
    Lo que estoy haciendo es que yo se que numeros es un arreglo, entonces a cada una una de las
    posiciones de ese arreglo las estoy guardando dinamicamente dentro de esas variables one,two, three
    //Con destructuraci칩n
    const [one, two, three] = numeros;
    console.log(one, two, three);     //1 2 3 

    Vamos a verlo con objetos:

    Tenemos un objeto para destructurar:

    const persona = {
      nombre: "Jon",
      apellido: "MirCha",
      edad: 35
    };

    Aca es lo mismo que hicimos con arreglos. Creamos un objeto, dentro de ese objeto van a ir variables y le voy
    asignar las propiedades que esten asignadas al objeto persona. De esta forma logramos la destructuracion(o sea
    guardamos los valores de las propiedades del objeto persona en diferentes variables). En la destructuracion
    de objetos ES IMPORTANTE que la variable se llame IGUAL que la propiedad a la cual pretendo aislar en una sola
    variable.

    let { nombre, apellido, edad } = persona;
    console.log(nombre, apellido, edad);    // Jon MirCha 25

    Vamos con el mismo ejemplo pero cambiando el orden de las variables(edad por apellido). En este caso no pasa nada
    si invertimos las variables ya que dentro del objeto busca una propiedad que se llame igual que la varible y le 
    asigna dicho valor.

    let { nombre, edad, apellido } = persona;
    console.log(nombre, apellido, edad);
    
     */


    /* **********     Curso JavaScript: 19. Objetos literales - #jonmircha     ********** */
    /* 
    OBJETOS LITERALES -> una nueva forma de escribir atributos y metodos, incluso de asignarlos.
    

    Aca lo que hacemos es crear dos variables: nombre y edad
    let nombre = "kEnAi",
      edad = 7;

    Aca lo que hacemos es crear un objeto al cual le estoy asignando la propiedad nombre, y a esa propiedad nombre
    le estoy asignando como valor la variable nombre. Le asigno la propiedad edad, a la cual le voy asignar como
    su valor la variable edad. Y ademas tiene una funcion. ESTO ES SIN ES6

    const perro = {
      nombre: nombre,
      edad: edad,
      ladrar: function () {
        console.log("guauu guauu!!!")
      }
    }

    console.log(perro);   //{nombre: kEnAi, edad: 7, ladrar:f }
    perro.ladrar()        //guauu guauu!!!


    Gracias a la nueva actualizacion, ES6, JS lo que hace es "ahorrar" la escritura, es decir, yo creo un objeto
    el cual le voy asignar una propidad que se llame nombre y el valor de esa propiedad es igual a la variable que
    cree mas arriba que se llama nombre, entonces JS entiende que nombre: nombre y podemos directamente poner el 
    nombre de la propiedad y la coma. Como es en el caso de nombre y edad. Si quiero crear otra propiedad y colocar
    el valor lo hago perfectamente como es el caso de la propiedad raza. 
    Tambien cambian los metodos: directamente ponemos el nombre de la propiedad mas los corchetes, el cual indica
    que esa propiedad es un metodo, y abro llaves. Como ejemplo ladrar (){ cod a ejecutar }. En resumen para los
    metodos, saco los dos puntos, saco la palabra reservada function y lo demas queda igual.

    const dog = {
      nombre,
      edad,
      raza: "Callejero",
      ladrar() {
        console.log("guauu guauu guauu!!!")
      }
    }

    console.log(dog);    //{nombre: kEnAi, edad: 7, raza:"Callejero", ladrar: f}
    dog.ladrar();        //guauu guauu guauu
    
    */


    /* **********     Curso JavaScript: 20. Par치metros REST & Operador Spread - #jonmircha     ********** */
    /* 
    REST: son una forma de virtualmente ir agregando parametros infinitos(ya sea a funcion o dentro de una variable)
    Por ejemplo imaginemos que tenemos un arreglo, donde tenemos valores infinitos. Para hacer esto anteponemos
    tres puntos.


    Aca tenemos una funcion el cual tiene tres parametros, el terecer parametro viene acompa침ada con el REST(tres
    puntos), eso significa que puede recibir tres, cuatro o cinco parametros por eso ponemos REST.Todo lo que llegue
    despues con C lo voy a tratar como un arreglo, por lo tanto le aplico el metodo forEach para recorrer el array 
    e ir guardando cada elemento en n, una vez guardado en n, lo sumo a resultado y finalmente devuelve resultado.
    
    function sumar(a, b, ...c) {
      let resultado = a + b;

      c.forEach(function (n) {          
        resultado += n
      });

      return resultado;
    }

    console.log(sumar(1, 2));    //3
    console.log(sumar(1, 2, 3));   //6
    console.log(sumar(1, 2, 3, 4));  //10
    console.log(sumar(1, 2, 3, 4, 5));  //15
    console.log(sumar(1, 2, 3, 4, 5, 6));  //21
    console.log(sumar(1, 2, 3, 4, 5, 6, 7));  //28


    OPERADOR SPREAD: nos va permitir que cuando una expresion la tengamos que expandir en situaciones donde tengamos
    que guardar o almacenar multiples argumentos o elementos, lo podamos hacer. Se puede ejecutar en cualquier
    sentencia de nuestro codigo.


    Tenemos un arreglo arr1, y a su vez tenemos otro arreglo arr2. Y a partir de esos dos arreglos yo tengo que 
    crear un tercer arreglo que contengan estos dos arreglos(arr3). Si yo pongo arr3=[arr1,arr2] me va a salir el
    arreglo como un arreglo que contiene dos elementos que son dos arreglos, y como lo que yo quiero es tener un 
    solo arreglo que contenga los elementos del arr1 y arr2. Para eso utilizo el operador spread, utlizo los tres 
    puntos anteponiendolo antes de los nombres del arreglo. Entonces como resultado final, tengo un arreglo con
    los elementos de los arreglos arr1 y arr2, un arreglo con 10 elementos(o posiciones)

    const arr1 = [1, 2, 3, 4, 5],
      arr2 = [6, 7, 8, 9, 0];

    console.log(arr1, arr2);  //[1,2,3,4,5] [6,7,8,9,0]

    const arr3 = [...arr1, ...arr2];
    console.log(arr3);       //[1,2,3,4,5,6,7,8,9,0]
    */   


    /* **********     Curso JavaScript: 21. Arrow Functions - #jonmircha     ********** */
    /*
    Una arrow function basicamente, es como una funcion anonima o expresa, le quitamos la palabra function, y 
    despues de los corchetes le colocamos un igual y mayor que(=>). Cuando la funcion tiene una sola linea de 
    instruccion puedo OMITIR LAS llaves y dejar la funcion flecha en una sola linea de codigo
    
     const saludar = () => console.log(`Hola`);
    saludar();  //Hola 


    PARAMETROS: Cuando una funcion flecha no recibe parametros o recibe mas de un parametro obligatoriamente tengo
    que colocar los corchetes (como el ejemplo anterior o como en el ejemplo de simar), en cambio cuando una funcion
    flecha recibe argumentos o parametros no es necesario colocar los parentesis(como el ejemplo de abajo) 

     /* const saludar = nombre => console.log(`Hola ${nombre}`);
    saludar("Irma");  //Hola Irma
    
    
    Como nos evitamos escribir la palabra function, tambien nos podemos evitar escribir la palabra return. En el 
    ejemplo de la funcion anonima(la primera) creamos una variable sumar en donde voy a guardar la funcion que
    recibe dos parametros(a,b) y eso me retorna la suma de a y b. En cambio en la arrow function directamente
    creo la varible le pongo los dos parametros, coloco los signos => y en vez de poner el return directamente
    coloco a + b.
    
    const sumar = function (a, b) {
      return a + b;
    } 
    const sumar = (a, b) => a + b;

    console.log(sumar(9, 9));   //18
    
    
    En los ejemplos anteriores tuvimos funciones de una sola linea, veamos ahora funciones de varias lineas. En
    los casos donde teniamos una sola linea no era necesario abrir y cerrar llaves para colocar el codigo que va
    a ejecutarse, en cambio si tenemos varias lineas de codigos a ejecutarse es necesario colocar estas llaves,
    los codigos van separados por punto y coma.
    
     const funcionDeVariasLineas = () => {
       console.log("Uno");
       console.log("Dos");
       console.log("Tres");
     }

     funcionDeVariasLineas();   //Uno  Dos  Tres

     Las arrow function tambien sirven para los arreglos. Tenemos un arreglo llamada numeros, y tenemos que iterar
     sobre cada uno de los elementos de ese arreglo para imprimirlos en pantalla, para eso sabemos que tenemos
     el metodo forEach el cual recibe una funcion y esa funcion recibe como parametro el elemento que esta recorriendo el arreglo y la posicion.

    const numeros = [1, 2, 3, 4, 5];

    Ejemplo sin arrow function:

    numeros.forEach(function (el, index){
      console.log(`${el} esta en la posici칩n ${index}`)}
      );

    Ejemplo con arrow function(me queda en una sola linea de codigo, como tiene dos parametros utilizo los corchetes
    como es una sola linea de codigo no necesito utilizar las llaves y asi queda mas prolijo)

    numeros.forEach((el, index) => console.log(`${el} esta en la posici칩n ${index}`));

    // 1 esta en la posici칩n 0
       2 esta en la posici칩n 1
       3 esta en la posici칩n 2
       4 esta en la posici칩n 3
       5 esta en la posici칩n 4
    

    OTROS EJEMPLOS DE ARROW FUNCTION
      
    En esta funcion el this apunta al objeto global(que en google seria el window)
    function Perro() {
      console.log(this);
      }

      Perro(); //window
        
    En este objeto el this apunta al objeto perro
    const perro={
      nombre: "kenai",
      ladrar: function(){
        console.log(this)
      }
    }
    perro.ladrar();   //{nombre:kenai , ladrar:f}

    Si al objeto le cambio el metodo ladrar por una funcion flecha, el objeto this apuntaria al objeto global
     const perro = {
      nombre: "kenai",
      ladrar() => {
        console.log(this)
        }
      }

    perro.ladrar();  //window

    Las arrow function tienen la capacidad de saltarse el contexto en el que estan(en este caso el objeto) y heredar
    o reconocer el contexto en donde se encuentra su objeto padre en el que ha sido declarada. Por eso no es buena
    practica crear un metodo atraves de un arrow function en los objetos. 
    
    En el ejemplo de abajo utilizamos el metodo con la nueva actualizacion(sacando la palabra function ysacando los
    dos puntos), esa es la nueva forma de expresar los metodos en los objetos literales que si reconoce el contexto
    de donde se encuentra

    const perro = {
      nombre: "kenai",
      ladrar() {
        console.log(this)
        }
      }

      perro.ladrar(); //{nombre:kenai , ladrar:f}
    
     */





    /* **********     Curso JavaScript: 22. Prototipos - #jonmircha      ********** */
    // POO
    /*  
    Dentro de la programacion orientada a objeto(POO) hay cuatro conceptos muy importantes:
    Clases - Son un modelo a seguir.
    Objetos - Es una instancia de una clase, tiene dos caracteristicas atributos y metodos:
      Atributos - es una caracter칤stica o propiedad del objeto (son variables dentro de un objeto)
      M칠todos - son las acciones que un objeto puede realizar (son funciones dentro de un objeto)
     
    Vamos a un ejemplo. En este caso vamos a crear dos objetos, animal y animal2(los dos objetos crean un prototipo 
    de objeto). Los dos objetos son muy similares entre si, pero para hacerlos tuve que copiar el mismo codigo con 
    diferentes valores, y esto NO ES FUNCIONAL. Para eso , POO, tenemos las clases. Las clases son un modelo a seguir del cual podemos crear varios objetos.

    
      const animal = {
      nombre: "Snoopy",
      sonar() {
        console.log("Hago sonidos por que estoy vivo");
      }
    }

    const animal2 = {
      nombre: "Lola Bunny",
      sonar() {
        console.log("Hago sonidos por que estoy vivo");
      }
    }

    console.log(animal);   //{nombre: 'Snoopy' , sonar:f}
    console.log(animal2);   //{nombre: 'Lola Bunny' , sonar:f}


    Lo que vamos hacer es crear una FUNCION CONSTRUCTORA, como su nombre lo dice lo voy a construir una sola vez y
    a partir de ella voy a generar nuevas instancias, nuevos objetos, que sean de este tipo de funcion constructora.
    Una funcion en si genera una prototipo vacio. En las clases, en estas funciones la inicial siempre va ir en 
    MAYUSCULA

    //Funci칩n constructora
         function Animal(nombre, genero) {
          //Atributos
          this.nombre = nombre;
          this.genero = genero;

          //M칠todos(no vamos a utilizar arrow functions ni la nueva forma de hacer, sino q utlizamos la de siempre)
          this.sonar = function () {
            console.log("Hago sonidos por que estoy vivo");
          }

          this.saludar = function () {
            console.log(`Hola me llamo ${this.nombre}`);
          }
        } 

        Con la forma de abajo, con el new, logramos crear dos objetos:

      const snoopy = new Animal ('Snoopy' , 'Macho'),
         lolaBunny= new Animal ('Lola Bunny' , 'Hembra');

        Si observamos en la consola, ese animal que creamos, su prototipo es objeto, su constructor es esa
        funcion constructura que esta arriba(Animal)

      console.log(snoopy);  //{nombre: 'Snoopy' , genero: 'Macho' , sonar:f}
      console.log(lolaBunny);   //{nombre: 'Lola Bunny' , genero: 'Hembra' , sonar:f}


      snoopy.sonar(); // Hago sonidos porque estoy vivo
      snoopy.saludar(); // Hola me llamo Snoopy

      lolaBunny.sonar(); // Hago sonidos porque estoy vivo
      lolaBunny.salunar(); // Hola me llamo Lola Bunny

    
    Cuando nosotros creamos funciones constructoras de las cuales pretendemos crear prototipos para JS en la 
    programacion orientada a objeto lo ideal es que nuestras funciones constructoras solamente tengan los atributos
    y saquemos los metodos de la funcion y se los peguemos al prototipo.Entonces finalmente apareceria en el 
    prototipo el prototipo objeto, el metodo saludar y sonar, y la funcion constructora Ejemplo:


    //Funci칩n constructora donde asignamos los m칠todos al Prototipo, no a la funci칩n como tal
      function Animal(nombre, genero) {
       //Atributos
       this.nombre = nombre;
       this.genero = genero;
     } 

     Asignando prototipos: mandamos a llamar el nombre de la funcion constructora(Animal) ponemos un punto, luego
     ponemos la palabra reservada prototype, colocamos otro punto, y finalmente colocamos el nombre del metodo.Ponemos 
     el igual y seguido colocamos la funcion. Con esto asignamos por fuera al prototipo. Lo que va hacer es que cada vez
     que nosotros generemos una nueva variable de tipo animal, la funcion nos va a tener la asignacion de los atributos
     y los metodos van a quedar solamente a ese prototipo Animal, eso va a mejorar el rendimiento y el espacio en 
     memoria.

    //M칠todos agregados al prototipo de la funci칩n constructora
     Animal.prototype.sonar = function () {
      console.log("Hago sonidos por que estoy vivo");
    }

    Animal.prototype.saludar = function () {
      console.log(`Hola me llamo ${this.nombre}`);
    } 

    snoopy.sonar(); // Hago sonidos porque estoy vivo
    snoopy.saludar(); // Hola me llamo Snoopy

    lolaBunny.sonar(); // Hago sonidos porque estoy vivo
    lolaBunny.salunar(); // Hola me llamo Lola Bunny
    */

    /* **********     Curso JavaScript: 23. Herencia - #jonmircha      ********** */

    /* 

    Para el ejemplo de herencia voy a utilizar la funcion constructora Animal, la misma q utilizamos anteriormente

    function Animal(nombre, genero) {
       //Atributos
       this.nombre = nombre;
       this.genero = genero;
     } 


    //Herencia Protot칤pica- Capacidad de poder heredar caracteristicas de un padre a un hijo
     function Perro(nombre, genero, tamanio) {
      this.super = Animal;       //le estoy diciendo que su elemento padre va ser Animal
      this.super(nombre, genero);     //como super es la funcion constructora Animal, recibe los parametros del mismo
      this.tamanio = tamanio;         //le agregue un atributo adicional que no esta en la funcion constructora padre
    } 

    En this.super lo que hago es hacer la 'invocacion' de la funcion constructora Animal,pero realmente donde voy
    hacer la herencia es aca abajo. Voy asignar al prototipo de perro que sea una instancia de Animal
    //Perro est치 heredando de Animal
     
    Perro.prototype = new Animal();   //esta linea es la que esta haciendo la herencia


    Perro.prototype.constructor = Perro;    //aca lo que hago(puedo hacer) es generarle su propio constructor, a la 
     funcion constructora perro


     Como perro hereda todo lo de Animal puede utilizar sus respectivos metodos, osea los metodos de salunar y sonar, e 
     incluso puede generar nuevos metodos. Tambien podemos hacer una sobreescritura de los metodos del prototipo
     padre en el hijo

    //Sobreescritura de m칠todos del Prototipo padre en el hijo

     Perro.prototype.sonar = function () {   //al prototipo de perro vamos a sobreescribir el metodo sonar
      console.log("Soy un perro y mi sonido es un ladrido");     
    }

    Perro.prototype.ladrar = function () {    //al prototipo de perro le creamos un nuevo metodo
      console.log("Guauuu Guauuu !!!!");
    } 

     const snoopy = new Perro("Snoopy", "Macho", "Mediano")   


    console.log(snoopy); //aca su prototipo es esa funcion constructora de la cual hereda, es decir su prototipo es 
    Animal(el prototipo de animal era Objeto)
    

    snoopy.sonar();   //Soy un perro y mi sonido es un ladrido
    snoopy.saludar(); //Hola me llamo Snoopy
    snoopy.ladrar();  //Guauuu Guauuu !!!

   */





    /* **********     Curso JavaScript: 24. Clases - #jonmircha y Curso JavaScript: 25. M칠todos est치ticos, getters y setters - #jonmircha     ********** */
    /* class Animal {
      //el constructor es un m칠todo especial que se ejecuta en el momento de instanciar la clase
      constructor(nombre, genero) {
        this.nombre = nombre;
        this.genero = genero;
      }

      //M칠todos
      sonar() {
        console.log("Hago sonidos por que estoy vivo");
      }

      saludar() {
        console.log(`Hola me llamo ${this.nombre}`);
      }
    }

    class Perro extends Animal {
      constructor(nombre, genero, tamanio) {
        //con el m칠todo super() se manda a llamar el constructor de la clase padre
        super(nombre, genero);
        this.tamanio = tamanio;
        this.raza = null;
      }

      sonar() {
        console.log("Soy un perro y mi sonido es un ladrido");
      }

      ladrar() {
        console.log("Guauuu Guauuu!!!");
      }

      //un m칠todo est치tico se pueden ejecutar sin necesidad de instanciar la clase
      static queEres() {
        console.log("Los perros somos animales mam칤feros que pertenecemos a la familia de los caninos. Somos considerados los mejores amigos del hombre.");
      }

      //Los setters y getters son m칠todos especiales que nos permiten establecer y obtener los valores de atributos de nuestra clase
      get getRaza() {
        return this.raza;
      }

      set setRaza(raza) {
        this.raza = raza;
      }
    }

    Perro.queEres();

    const mimi = new Animal("Mimi", "Hembra"),
      scooby = new Perro("Scooby", "Macho", "Gigante");

    console.log(mimi);
    mimi.saludar();
    mimi.sonar();
    console.log(scooby);
    scooby.saludar();
    scooby.sonar();
    scooby.ladrar();
    console.log(scooby.getRaza);
    scooby.setRaza = "Gr치n Dan칠s";
    console.log(scooby.getRaza); */





    /* **********     Curso JavaScript: 26. Objeto console - #jonmircha     ********** */
    /* console.log(console);
    console.error("Esto es un error");
    console.warn("Esto es un aviso");
    console.info("Esto es un mensje informativo");
    console.log("Un registro de lo que ha pasado en nuestra aplicaci칩n");

    let nombre = "Jon",
      apellido = "MirCha",
      edad = 35;

    console.log(nombre);
    console.log(apellido);
    console.log(edad);
    console.log(nombre, apellido, edad);
    console.log(`Hola mi nombre es ${nombre} ${apellido} y tengo ${edad} a침os.`);
    console.log(`Hola mi nombre es %s %s y tengo %d a침os.`, nombre, apellido, edad);
    console.clear();
    console.log(window);
    console.log(document);
    console.dir(window);
    console.dir(document);
    console.clear();

    console.group("Cursos de @jonmircha en YouTube");
    console.log("Curso de JavaScript");
    console.log("Curso de Node.js");
    console.log("Curso de PWAs");
    console.log("Curso de Flexbox");
    console.log("Curso de Dise침o y Programaci칩n Web");
    console.groupEnd();

    console.groupCollapsed("Cursos de @jonmircha en YouTube");
    console.log("Curso de JavaScript");
    console.log("Curso de Node.js");
    console.log("Curso de PWAs");
    console.log("Curso de Flexbox");
    console.log("Curso de Dise침o y Programaci칩n Web");
    console.groupEnd();
    console.clear();
    console.log(console);
    console.table(Object.entries(console).sort());

    const numeros = [1, 2, 3, 4, 5],
      vocales = ["a", "e", "i", "o", "u"];

    console.table(numeros);
    console.table(vocales);

    const perro = {
      nombre: "Boni",
      raza: "Boxer",
      color: "cafe"
    }
    console.table(perro);
    console.clear();

    console.time('Cuanto tiempo tarda mi c칩digo');
    const arreglo = Array(1000000);

    for (let i = 0; i < arreglo.length; i++) {
      arreglo[i] = i;
    }

    console.timeEnd('Cuanto tiempo tarda mi c칩digo');
    //console.log(arreglo);

    console.clear();


    for (let i = 0; i <= 100; i++) {
      console.count("c칩digo for");
      console.log(i);
    }

    console.clear();

    let x = 3,
      y = 2,
      pruebaXY = "Se espera que X siempre sea menor que Y";

    console.assert(x < y, { x, y, pruebaXY }); */





    /* **********     Curso JavaScript: 27. Objeto Date - #jonmircha     ********** */
    /* console.log(Date());

    let fecha = new Date();
    console.log(fecha);
    //d칤a del mes
    console.log(fecha.getDate());
    //d칤a de la semana D L M Mi J V S -> 0 1 2 3 4 5 6
    console.log(fecha.getDay());
    //mes Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic -> 0 1 2 3 4 5 6 7 8 9 10 11
    console.log(fecha.getMonth());
    console.log(fecha.getFullYear());
    console.log(fecha.getHours());
    console.log(fecha.getMinutes());
    console.log(fecha.getSeconds());
    console.log(fecha.getMilliseconds());
    console.log(fecha.toString());
    console.log(fecha.toDateString());
    console.log(fecha.toLocaleString());
    console.log(fecha.toLocaleDateString());
    console.log(fecha.toLocaleTimeString());
    console.log(fecha.getTimezoneOffset());
    console.log(fecha.getUTCDate());
    console.log(fecha.getUTCHours());
    console.log(Date.now());
    let cumpleJon = new Date(1984, 4, 23);
    console.log(cumpleJon); */





    /* **********     Curso JavaScript: 28. Objeto Math - #jonmircha     ********** */
    /* console.log(Math);
    console.log(Math.PI);
    console.log(Math.abs(-7.8));
    console.log(Math.ceil(7.2));
    console.log(Math.floor(7.8));
    console.log(Math.round(7.49));
    console.log(Math.sqrt(81));
    console.log(Math.pow(2, 5));
    console.log(Math.sign(-0.3)); // -1 0 1
    console.log(Math.random());
    console.log(Math.round(Math.random() * 1000)); */





    /* **********     Curso JavaScript: 29. Operador de Cortocircuito - #jonmircha     ********** */
    /*
    Cortocircuito OR - cuando el valor de la izquierda en la expresi칩n siempre pueda validar a true, es el valor que se cargar치 por defecto

    Cortocircuito AND - cuando el valor de la izquierda en la expresi칩n siempre pueda validar a false, es el valor que se cargar치 por defecto
     */
    /*  function saludar(nombre) {
       nombre = nombre || "Desconocido";
       console.log(`Hola ${nombre}`);
     }

     saludar("Jon");
     saludar();

     console.log("cadena" || "Valor de la derecha");
     console.log(19 || "Valor de la derecha");
     console.log(true || "Valor de la derecha");
     console.log([] || "Valor de la derecha");
     console.log({} || "Valor de la derecha");
     console.log(false || "Valor de la derecha");
     console.log(null || "Valor de la derecha");
     console.log(undefined || "Valor de la derecha");
     console.log("" || "Valor de la derecha");
     console.log(-2 || "Valor de la derecha");
     console.log(0 || "Valor de la derecha");

     console.log(false && "Valor de la derecha");
     console.log(null && "Valor de la derecha");
     console.log(undefined && "Valor de la derecha");
     console.log("" && "Valor de la derecha");
     console.log(-2 && "Valor de la derecha");
     console.log(0 && "Valor de la derecha");

     console.log("cadena" && "Valor de la derecha");
     console.log(19 && "Valor de la derecha");
     console.log(true && "Valor de la derecha");
     console.log([] && "Valor de la derecha");
     console.log({} && "Valor de la derecha"); */





    /* **********     Curso JavaScript: 30. alert, confirm y prompt - #jonmircha     ********** */
    //console.log(window);
    //alert("Hola esto es una alerta");
    //confirm("Hola esto es una confirmaci칩n");
    //prompt("Hola esto es un aviso y le permite al usuario ingresar un valor");

    /* let alerta = alert("Hola esto es una alerta"),
      confirmacion = confirm("Hola esto es una confirmaci칩n"),
      aviso = prompt("Hola esto es un aviso y le permite al usuario ingresar un valor");

    console.log(alerta);
    console.log(confirmacion);
    console.log(aviso);
 */





    /* **********     Curso JavaScript: 31. Expresiones Regulares - #jonmircha     ********** */
    /*
     Expresiones Regulares
        Son una secuencia de caracteres que forma un patr칩n de b칰squeda, principalmente utilizada para la b칰squeda de patrones de cadenas de caracteres.

        https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular
        https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Regular_Expressions
    */

    /*  let cadena = "Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptatem fuga cupiditate dolores saepe, praesentium sit eaque recusandae id sapiente similique, laudantium voluptatum perferendis ea iure ad odio doloremque earum voluptate.";

     let expReg = new RegExp("lorem", "ig");
     console.log(expReg.test(cadena));
     console.log(expReg.exec(cadena));

     let expReg2 = /lorem{1,}/ig;
     console.log(expReg2.test(cadena));
     console.log(expReg2.exec(cadena)); */





    /* **********     Curso JavaScript: 32. Funciones An칩nimas Autoejecutables - #jonmircha     ********** */
    /*    //Funci칩n An칩nima Autoejecutables
       (function () {
         console.log("Mi primer IIFE");
       })();

       (function (d, w, c) {
         console.log("Mi segunda IIFE");
         console.log(d);
         console.log(w);
         c.log("Este es un console.log")
       })(document, window, console);


       //Formas de escribir las funciones An칩nimas Autoejecutables
       //Cl치sica
       (function () {
         console.log('versi칩n Cl치sica')
       })();

       //La Crockford (JavaScript The Good Parts)
       ((function () {
         console.log('versi칩n Crockford')
       })());

       //Unaria
       +function () {
         console.log('versi칩n Unaria')
       }();

       //Facebook
       !function () {
         console.log('versi칩n Facebook')
       }(); */
  </script>
</body>

</html>
