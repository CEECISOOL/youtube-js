<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Fundamentos JavaScript</title>
</head>

<body>
  <h1>Fundamentos JavaScript</h1>
  <script>
    /* **********     Curso JavaScript: 3. Variables: var VS let - #jonmircha     ********** */

    /* var hola = "Hola Mundo";
    let hello = "Hello World";
    console.log(hola);
    console.log(hello);
    console.log(window);
    console.log(window.hola);
    console.log(window.hello); 
    //Ambito de bloque
    //Esto es un bloque - comentario de una linea
    Esto
    es
    un
    comentario
    de
    varias
    l铆neas 
     console.log ("****************var*****************");
    var musica = "Rock";
    console.log("Variable M煤sica antes del Bloque", musica);
    {
      var musica = "Pop";
      console.log("Variable M煤sica dentro del Bloque", musica);
    }
    console.log("Variable M煤sica despu茅s del Bloque", musica);
    console.log("****************let*****************");
    let musica2 = "Rock";
    console.log("Variable M煤sica antes del Bloque", musica2);
    {
      let musica2 = "Pop";
      console.log("Variable M煤sica dentro del Bloque", musica2);
    }
    console.log("Variable M煤sica despu茅s del Bloque", musica2); */





    /* **********     Curso JavaScript: 4. Constantes (const) - #jonmircha     ********** */

    /*  let a;
     const PI = 3.1416;
     //const NUEVE;
     console.log(PI);
     //PI = 3.15;

     a = "kenai";
     console.log(a);

     const objeto = {
       nombre: "Jon",
       edad: 35
     }

     const colores = ["blanco", "negro", "azul"];

     console.log(objeto);
     console.log(colores);

     objeto.correo = "jonmircha@gmail.com";
     colores.push("anaranjado");

     console.log(objeto);
     console.log(colores); */





    /* **********     Curso JavaScript: 5. Cadenas de Texto (Strings) - #jonmircha     ********** */

    /*
        //Cadenas de Texto aka Strings
        let nombre = "Jon";
        let apellido = 'MirCha';
        let saludo = new String("Hola Mundo"); -> es una manera de declarar una cadena de texto es con su constructor o
        sea con el objeto string. La palabra new String: la palabra reservada new es un operador, que me va permitir
        crear un objeto nuevo de un cierto tipo de dato, en este caso como le colocamos String, me va crear una cadena
        de texto(nadie utiliza esta forma, ya que es mas practico utilizar los " " ' ').
        let lorem = "       Lorem ipsum, dolor sit amet consectetur adipisicing elit. Est, et dolorum. Adipisci sequi, voluptates accusamus earum magnam non pariatur odit consequuntur dicta modi. Quam soluta aliquid nam ea quod dolore.      ";

        console.log(nombre, apellido, saludo);
        console.log(
          nombre.length,
          apellido.length,
          saludo.length,
          nombre.toUpperCase(),     toUpperCase ->es un metodo para que todas las palabras se escriban en MAYUSCULA
          apellido.toLowerCase(),   toLowerCase ->es un metodo para que todas las palabras se escriban en MINUSCULA
          lorem.includes("amet"),   includes  ->es para verificar si en la variable lorem se incluye la palabra amet
          lorem.includes("jon"),     
          lorem,
          lorem.trim(),             trim  ->saca los "espacios en blanco que estan al principio y al final de lorem
          lorem.split(" "),         
          lorem.split(",")          split  ->convierte la cadena de texto en un arreglo(por ejemplo si entrecomillas
          tiene un espacio en blanco va a armar el arreglo separando la cadena de texto por los espacios en blanco
          o sea va a seperar cada vez que encuentre un espacio en blanco; en cambio si tiene la coma significa que va 
          a seperar la cadena de texto hasta donde haya una coma)
        );

     */





    /* **********     Curso JavaScript: 6. Template Strings - #jonmircha     ********** */

    /* let nombre = "Jon";
    let apellido = "MirCha";
 
    //Concatenaci贸n
    //let saludo = "Hola mi nombre es " + nombre + " " + apellido + ".";
    //console.log(saludo);

    //Interpolci贸n de variables
    //Template String
    /* let saludo2 = `Hola mi nombre es ${nombre} ${apellido}.`;
    console.log(saludo2);

    let ul = "<ul>< li > Primavera</li><li>Verano</li><li>Oto帽o</li><li>Invierno</li></ul > ";

    console.log(ul);

    let ul2 = `
      <ul>
        <li>Primavera</li>
        <li>Verano</li>
        <li>Oto帽o</li>
        <li>Invierno</li>
    </ul>
    `;

    console.log(ul2);

    let ul3 = "<ul>";
    ul3 += "<li> Primavera</li>";
    ul3 += "<li>Verano</li>";
    ul3 += "<li>Oto帽o</li>";
    ul3 += "<li>Invierno</li>";
    ul3 += "</ul>";

    console.log(ul3);
 */





    /* **********     Curso JavaScript: 7. N煤meros (Numbers) - #jonmircha     ********** */

    /* let a = 2;
    let b = new Number(1);  la palabra reservada new es un operador, que me va permitir crear un objeto nuevo de un cierto tipo de dato, en este caso como le colocamos Number y crea un numero.
    let c = 7.19;
    let d = "5.6";

    console.log(a, b);
    console.log(c.toFixed(1));    toFixed ->dice cuantos numeros DECIMALES va a tener el numero.  //7.2
    console.log(c.toFixed(5));                                                                    //7.19000
    console.log(parseInt(c));     parseInt ->el metodo devuelve la parte entera del numero        //7
    console.log(parseFloat(c));   parseFloat ->devuelve la parte entera y la parte decimal de un numero   //7.19
    console.log(typeof c, typeof d);    type of ->te dice que tipo de dato es la variable  //number string
    console.log(a + b);           //3
    console.log(c + parseInt(d));       ->para hacer la suma de numero mas cadena de texto que es un numero, le coloco
    el parseInt, pero en este caso suma la parte entera unicamente; abajo utilizamos parseFloat por el cual me hace la suma correctamente (7.19 + '5.6') osea suma el numero mas la cadena de texto que es un numero, suma la parte 
    entera y la parte decimal.
    console.log(c + parseFloat(d));
    esta es otra forma de hacerlo, poner el Number adelante del parse:
    console.log(c + Number.parseInt(d));    
    console.log(c + Number.parseFloat(d)); */





    /* **********     Curso JavaScript: 8. Booleans - #jonmircha     ********** */

    /* let verdadero = true;
    let falso = false;
    let v = Boolean(true);
    let f = Boolean(false);

    console.log(verdadero, falso, v, f);
    console.log(typeof verdadero, typeof falso);   -> te dice que es un tipo de dato Boolean(booleano)
    console.log(Boolean(0));
    console.log(Boolean(-7));
    console.log(Boolean(""));
    console.log(Boolean(" ")); */





    /* **********     Curso JavaScript: 9. undefined, null & NaN - #jonmircha     ********** */

    //undefined indica que no se ha inicializado una variable y que el valor est谩 ausente
    /* let indefinida;
    console.log(indefinida); 

    //null es un valor especial que indica la ausencia de un valor
     let nulo = null;
    console.log(null); 

    //NaN - Not a Number
     let noEsUnNumero = "hola" * 3.7;
    console.log(noEsUnNumero); */




    /* **********     Curso JavaScript: 10. Funciones - #jonmircha     ********** */

    /*
    Una funci贸n es un bloque de c贸digo, autocontenido, que se puede definir una vez y ejecutar en cualquier momento. Opcionalmente, una funci贸n puede aceptar par谩metros y devolver un valor.

    Las funciones en JavaScript son objetos, un tipo especial de objetos:

    Se dice que las funciones son ciudadanos de primera clase porque pueden asignarse a un valor, y pueden pasarse como argumentos y usarse como un valor de retorno.
    

    //Declaraci贸n de funci贸n
      function estoEsUnaFuncion() {             ->empieza la funcion
       console.log("Uno");
       console.log("Dos");                        ->lo que esta entre llaves({}) es el codigo a ejecutarse
       console.log("Tres");
     }

    //Invocaci贸n de funci贸n
    estoEsUnaFuncion();
    estoEsUnaFuncion();
    estoEsUnaFuncion();
    estoEsUnaFuncion(); 

    function unaFuncionQueDevuelveValor() {
      console.log("Uno");
      return 19;
      console.log("Dos");
      console.log("Tres");
      return "La funci贸n ha retornado una Cadena de texto";
    } 

    //let valorDeFuncion = unaFuncionQueDevuelveValor();

    //console.log(valorDeFuncion);    //Uno  19

    en la funcion unaFuncionQueDevuelveValor ->cuando el interprete encuentre la palabra reservada RETURN, 
    automaticamente deja de leer las lineas de codigo que estan debajo de esa palabra reservada, por ese motivo
    cuando hago el console.log(valorDeFuncion) me devuelve Uno 19, porque despues de retornar el 19, no lee las
    otras lineas de codigo, las ignora.
    
    function saludar(nombre = "Desconocido", edad = 0) {
       console.log(`Hola mi nombre es ${nombre} y tengo ${edad} a帽os.`);
     } 

    //saludar("kEnAi", 7);
    //saludar();

    //Funciones declaradas VS funciones expresadas

    funcionDeclarada();  ->si yo invoco la funcion declarativa antes de su definicion, no pasa nada, me invoca la 
    funcion igualmente, a eso le llamamos HOISTING(como que 'sube' la funcion arriba de la invocacion, lo hace 
    automaticamente JS), en resumen no importa donde invoque la funcion porque el interprete la va invocar igual 

     function funcionDeclarada() {
      console.log("Esto es un funci贸n declarada, puede invocarse en cualquier parte de nuestro c贸digo, incluso antes de que la funci贸n sea declarada");
    } 

    funcionDeclarada();
    
    funcionExpresada();  ->si yo invoco la funcion anonima o expresiva antes de su definicion me va tirar un error,
    por lo tanto no puedo invocarla en cualquier lugar o antes de declarar la funcion porque me tira un error('no 
    puedes invocar la funcion porque no fue declarada, porque la estas invocando antes de su inicializacion')

    //funci贸n an贸nima (no tiene nombre) o funcion expresada(la estamos asignando como valor a una variable)
     const funcionExpresada = function () {
      console.log("Esto es una funci贸n expresada, es decir, una funci贸n que se le ha asignado como valor a una variable, si invocamos esta funci贸n antes de su definici贸n JS nos dir谩 'Cannot access 'funcionExpresada' before initialization'")
    } 

    //funcionExpresada();
    */




    /* **********     Curso JavaScript: 11. Arreglos (Arrays) - #jonmircha     ********** */

    /*     const a = [];
        const b = [1, true, "Hola", ["A", "B", "C", [1, 2, 3]]];
        console.log(a);
        console.log(b);
        console.log(b.length);
        console.log(b[2]);
        console.log(b[0]);
        console.log(b[3]);
        console.log(b[3][2]);
        console.log(b[3][3][0]);

        const c = Array.of("X", "Y", "Z", 9, 8, 7);  

        const d = Array(100).fill(false);      ->Array(n).fill('algo') donde n quiere decir cuantas posiciones tiene 
        el arreglo y lo que esta adentro de fill quiere decir el tipo de dato q va contener ese arreglo. En este caso hice un arreglo de 100 posiciones que tengan el valor booleano false.

        console.log(d);

        const e = new Array();      ->la palabra reservada new es un operador, que me va permitir crear un objeto
        nuevo de un cierto tipo de dato, en este caso como le colocamos Array, me va crear un arreglo

        console.log(c);
        console.log(e);

        const f = new Array(1, 2, 3, true, false);
        console.log(f);

        const colores = ["Rojo", "Verde", "Azul"];
        console.log(colores);

        colores.push("Negro");     ->push agrega al final del arreglo el valor negro(en este caso) al arreglo colores
        console.log(colores);

        colores.pop();             ->pop elimina el ultimo elemento de arreglo colores
        console.log(colores);

        colores.forEach(function (el, index) {
          console.log(`<li id="${index}">${el}</li>`);
        });                                                 

        el forEach nos permite ejecutar una funcion por cada uno de los elementos que tenga el arreglo. Por ejemplo
        en este ejemplo el significa elemento, mientras que index es el numero de indice del elemento. Con el forEach
        lo que hacemos en si es recorrer el elemento. El resultado seria: 
        <li id="0">Rojo</li>
        <li id="1">Verde</li>
        <li id="2">Azul</li>
        
        */





    /* **********     Curso JavaScript: 12. Objetos - #jonmircha     ********** */

    /* let a = new String("Hola");
    //console.log(a)

    const b = {}
    console.log(b);

    const c = new Object(); la palabra reservada new es un operador, que me va permitir crear un objeto nuevo de un
    cierto tipo de dato, en este caso como le colocamos el prototipo Object, me va crear un objeto
 
    un objeto es una coleccion de llaves:valores(key:value) y se separan con acento.Puede contener cualquier 
    tipo de dato.
     dentro de un objeto a las variables se le van a llamar atributos/propiedades(nombrem apellido, edad, 
     pasatiempos, soltero,contacto) y a las funciones se les llama m茅todos(saludar, decirMiNombre) 
        const jon = {
          nombre: "Jon",
          apellido: "MirCha",
          edad: 35,
          pasatiempos: ["Correr", "Hacer ejercicio", "Dar clases"],
          soltero: false,
          contacto: {
            email: "jonmircha@gmail.com",
            twitter: "@jonmircha",
            movil: "5215512345678"
          },
          saludar: function () {
            console.log(`Hola :)`)
          },
          decirMiNombre: function () {
            console.log(`Hola me llamo ${this.nombre} ${this.apellido} y tengo ${this.edad} a帽os y me puedes seguir como ${this.contacto.twitter} en twitter.`)   //this hace referencia al objeto donde se esta trabajando,
            por ejemplo si ponemos this.nombre, si nombre cambia, en la funcion tambien cambia
          }
        }
             ACCEDIENDO AL OBJETO: con corchete o con punto(es la forma mas utilizada y se recomienda utilizar punto)
        console.log(jon);    //imprime todos elementos del objeto
        console.log(jon["nombre"]);    //accedo con corchete,imprime el nombre
        console.log(jon["apellido"]);  //accedo con corchete, imprime el apellido
        console.log(jon.nombre);       //accedo con punto, imprime el nombre
        console.log(jon.apellido);     //accedo con punto, imprime apellido
        console.log(jon.edad);      
        console.log(jon.soltero);
        console.log(jon.pasatiempos);   //me va imprimir el arreglo completo
        console.log(jon.pasatiempos[1]);    //como pasatiempos es un arreglo, accedo al arreglo con corchete e imprimo 
        el elemento 1(hacer ejercicios)
        console.log(jon.contacto);       //me va imprimir el objeto completo
        console.log(jon.contacto.twitter);       //como es un objeto utlizo la forma de acceder del punto, accedo al 
        elemento del objeto TWITTER
        jon.saludar();   //invoco la funcion que esta dentro del objeto jon
        jon.decirMiNombre();

        console.log(Object.keys(jon));     //Object.keys imprime en un arreglo las llaves(nombre,apellido, edad, pasatiempos, soltero, contacto, saludar, decirMiNombre)
        console.log(Object.values(jon));   //Object.values imprime en un arreglo los valores(jon,mircha,etc)
        console.log(jon.hasOwnProperty("nombre"));   //me permite saber si un objeto tiene esa propiedad, o sea que si un objeto tiene el nombre de la propiedad que le paso; me devuelve true o false. En este caso me devuelve true
        console.log(jon.hasOwnProperty("nacimiento"));  //false
     */





    /* **********     Curso JavaScript: 13. Tipos de Operadores - #jonmircha     ********** */

    /* OPERADORES:
    
    Aritm茅ticos:  + - * / % ()  

    let a = 5 + (5 - 10) * 3;
    let modulo = 5 % 2;

    console.log(a);
    console.log(modulo);
 

     Relacionales: >, <,   >=, <=, ==, ===, !=, !== 

     console.log(8 > 9);
    console.log(9 > 8);
    console.log(8 >= 9);
    console.log(9 >= 8);
    console.log(7 < 7);
    console.log(7 <= 7); 

    
    = 1 igual es asignaci贸n  de variable
    == 2 iguales es comparacion de valores
    === 3 igulaes es comparaci贸n de tipo de dato y de valor
    

    console.log(7 == 7);
    console.log("7" == 7);
    console.log(0 == false);

    console.log(7 === 7);
    console.log("7" === 7);
    console.log(0 === false); 

   Incremento Decremento 
     let i = 2;

    console.log(i++);   //2    pero pasa a 3
    console.log(++i);   //4     (3 y le sumo uno)
    

    //i = i + 2;  //3
    //i += 2;     //3
    //i *=3;      //9


    //operador unario
    i++;    cuando vamos de uno en uno, suma uno
    i--;       cuando vamos de uno en uno, restamos uno
    ++i;       es lo mismo pero cambia la posicion de los signos
    --i;       es lo mismo pero cambia la posicion de los signos
    console.log(i); 

   
    L贸gicos
      ! - Not : Niega, es decir lo que es verdadero lo vuelve falso y viceversa
      || - Or: Cuando tengo 2 o m谩s condiciones, con que una se cumpla, es decir sea verdadera, el OR ser谩 verdadero.
      && - And: Cuando tengo 2 o m谩s condiciones, todas tienen que cumplirse, es decir ser verdaderas, para que AND se valide 
    
    console.log(!true);
    console.log(!false);
    console.log((9 === 9) || ("9" === 9));
    console.log((9 === 9) && ("9" === 9));
    console.log((9 === 9) && ("9" === "9")); */





    /* **********     Curso JavaScript: 14. Condicionales - #jonmircha     ********** */

    /*
     IF - ELSE
    
    let edad = 9;

    if (edad > 17) {
      console.log("Eres mayor de Edad");
    } else {
      console.log("Eres menor de Edad");
    }

    if (edad >= 18) {
      console.log("Eres mayor de Edad");
    } else {
      console.log("Eres menor de Edad");
    }

    if (edad < 18) {
      console.log("Eres menor de Edad");
    } else {
      console.log("Eres mayor de Edad");
    }

    if (edad <= 17) {
      console.log("Eres menor de Edad");
    } else {
      console.log("Eres mayor de Edad");
    } 
    
    
    
    IF - ELSE IF - ELSE
      D茅jame Dormir - 0hrs - 5hrs
      Buenos dias 6hrs - 11hrs
      Buenas tardes 12hrs - 18hrs
      Buenas noches 19hrs - 23hrs
    
    
    let hora = 23;
    if (hora >= 0 && hora <= 5) {
      console.log("D茅jame dormir");
    } else if (hora >= 6 && hora <= 11) {
      console.log("Buenos d铆as");
    } else if (hora >= 12 && hora <= 18) {
      console.log("Buenas tardes");
    } else {
      console.log("Buenas noches");
    }

    if (hora < 6) {
      console.log("D茅jame dormir");
    } else if (hora > 5 && hora < 12) {
      console.log("Buenos d铆as");
    } else if (hora > 11 && hora < 19) {
      console.log("Buenas tardes");
    } else {
      console.log("Buenas noches");
    } 
    
    
    OPERADOR TERNARIO (condici贸n) ? verdadero : falsa 
      console.log("Operador Ternario");

    podemos poner todo junto (condicion,verdadero y falso) o ser mas ordenado y dejarlo en
    lineas separadas:
     let eresMayor = (edad >= 18)
       ? "Eres mayor de Edad"
       : "Eres menor de Edad";
     console.log(eresMayor); 

    SWITCH -CASE
    
    domingo -0
    lunes - 1
    martes - 2
    mi茅rcoles - 3
    jueves - 4
    viernes - 5
    s谩bado - 6
    
    
    
    let dia = 2;

    switch (dia) {
      case 0:
        console.log("Domingo");
        break;
      case 1:
        console.log("Lunes");
        break;
      case 2:
        console.log("Martes");
        break;
      case 3:
        console.log("Mi茅rcoles");
        break;
      case 4:
        console.log("Jueves");
        break;
      case 5:
        console.log("Viernes");
        break;
      case 6:
        console.log("S谩bado");
        break;
      default:
        console.log("El d铆a no existe");
        break;
    }
    el break le quiere decir al lenguaje de programacion que cuando este en un caso y lea todo el codigo y si no se 
    cumple el caso, que salga de ese caso y pase al siguiente. Si omitimos el break el switch lee directamente todos los casos
    el default quiere decir que si no se cumple ninguno de esos casos, o sea que el caso sea uno particular
    y no corresponda a los casos de arriba, entonces correra esa linea de codigo(por ejemplo se va a imprimir
    el dia no existe)
 */


    /* **********     Curso JavaScript: 15. Ciclos (Loops) - #jonmircha     ********** */

    /*  let contador = 0;

     while (contador < 10) {
       console.log("while " + contador);
       contador++;
     }

     mientras(while) contador sea menor que 10, imprime while + contador, y para que no sea un loop infinito
     (o sea que contador no valga 0 siempre e imprima while 0 infinitamente) vamos a incrementar el contador a 1.
     Entonces queria : while 0, while 1, while 2, while 3, while 4, while 4, while 5, while 6, while 7, 
     while 8, while 9, y en el momento que llegaria el while 10 la condicion no se cumple, por lo tanto no entra.
     En resumen, lo que hace el while es que primero se fija si cumple la condicion y luego ejecuta el codigo
     que esta dentro.

     do {
       console.log("do while " + contador);
       contador++;
     } while (contador < 10); 
     
     el do while lo que hace es primero ejecutar el codigo (console.log...) y luego se fija que cumpla la condicion
     en este caso el ejemplo quedaria:  do while 0, do while..., do while 9.
     La diferencia con el while es que si por ejemplo nosotros cambiamos el contador a 10, en el do while se va 
     a imprimir POR LO MENOS UNA VEZ (quedaria do while 10), en cambio con el while como primero se fija si se 
     cumple la condicion por lo tanto como la condicion no se cumple, entonces no se imprime nada.
     EN RESUMEN con do while siempre se va imprimir por lo menos una vez ya que analiza la condicion luego de 
     ejecutar el codigo, y con while no se va imprimir si no se cumple la condicion, ya que primero analiza
     la condicion y luego ejecuta el codigo.
     
     
    for (inicializaci贸n de variable; condici贸n; decremento o incremento) {
      sentencias que ejecuta el for
      sentencias que ejecuta el for
      sentencias que ejecuta el for
    } 
    
    
    for (let i = 0; i < 10; i++) {
      console.log("for " + i);
    }                              //for 0, for 2, for 3, for 4, for 5, for 6, for 7, for 8, for 9

    let numeros = [10, 20, 30, 40, 50, 60, 70, 80, 90, 100];

    for (let i = 0; i < numeros.length; i++) {
      console.log(numeros[i]);
    }                               //10, 20, 30, 40, 50, 60, 70, 80, 90, 100

    esto sirve para RECORRER arreglos(como el forEach)
    En este caso puse que la i sea menor que el largo del arreglo, por lo tanto va imprimir todos los elementos del
    arreglo, en cambio si ponia que i<5  se iba a imprimir: 10, 20, 30, 40, 50 (de la posicion 0 a la 4, ya que la
    posicion 5 no cumple con la condicion, o sea que la posicion 5 es igual a 5 y no menor que 5)

    FORIN, FOROF: La diferencia de los dos es que for in nos permite recorrer solamente las propiedades de un 
    objeto, en cambio con el for of me va permitir recorrer todos los elementos de cualquier objeto que sea 
    iterable en JS(arreglos, cadenas de texto)


    -FOR IN  
     for (const key in object) {
        
      }

    -FOR OF ->
    for (const iterator of object) {
      
    }

    const jon = {
      nombre: "Jon",
      apellido: "MirCha",
      edad: 35
    }

    for (const propiedad in jon) {
      console.log(propiedad);
    }         //vamos a recorrer las propiedades del objeto JON,va imprimir las propiedades, por lo tanto
    lo que imprime es: nombre, apellido, edad (solo los nombres de las propiedades) lo que me permite recorrer
    o iterar todas las propiedades del objeto jon.


    for (const propiedad in jon) {
      console.log(`Key: ${propiedad}, Value: ${jon[propiedad]}`);
    }        //vamos a recorrer las propiedades del objeto JON, y en este caso lo que hago es imprimir las 
    propiedades y los valores de dichas propiedades. En el objeto jon, imprimir la propiedad como lo hicimos 
    anteriormente, al momento de imprimir el valor tengo dos opciones jon.propiedad o jon[propiedad]. En este caso 
    vamos a utlizar la opcion de los corchetes ya que cuando trabajamos con el for in y utlizamos el punto nos va 
    salir undefined en ves del valor, en cambio si utlizamos corchetes salen los valores.
    Lo que imprime es: Key:nombre ,Value:"Jon" ; Key:apellido ,Value:路MirCha"  Key:edad ,Value: 35


    for (const elemento of numeros) {
      console.log(elemento);
    }          //aca vamos a recorrer los elementos del arreglo NUMEROS, por lo que imprime los elementos del
    arreglo de numeros. Lo que imprime es: 10,20,30,40,50,60,70,80,90,100

    let cadena = "Hola Mundo";

    for (const caracter of cadena) {
      console.log(caracter);   //aca vamos a recorrer los caracteres de la varible cadena, me va imprimir los 
      caracteres incluyendo los espacio. Lo que imprime es: H,o,l,a, ,M,u,n,d,o
    } */


    /* **********     Curso JavaScript: 16. Manejo de Errores - #jonmircha     ********** */
    /*  try {
       console.log("En el Try se agrega el c贸digo a evaluar");     aca se pone el cod a evaluar
       noExiste;
       console.log("Segundo mensaje en el try");
     } catch (error) {
       console.log("Catch, captura cualquier error surgido o lanzado en el try");  si el cod a evaluar tiene un error 
       se imprime lo q esta dentro del console.log
       console.log(error); (con esta opcion puedo hacer que me imprima el error en la consola)
     } finally {
       console.log("El bloque finally se ejecutar谩 siempre al final de unbloque try-catch");
     }

     el codigo quedaria(primero se imprime el primer conselo.log, luego se imprime catch q encontro un error, luego se 
     imprime que error encontro, y finalmente se imprime el finally; el segundo console.log no se imprime ya que
     antes de ese console.log esta el error, y cuando la consola encuentra ese error todo lo que esta abajo no se
     evalua):
     -En el Try se agrega el codigo a evaluar (porque no hay error en el console.log)
     -Catch, captura cualquier error surgido o lanzado en el try(porque llame una variable que no esta declarada 
     noExiste, por lo tanto hay un error y el catch captura el error)
     -Reference error: noExiste is not defined ...
     -El bloque finally se ejecutara siempre al final de unbloque try-catch (el bloque finally siempre se va ejecutar)

     Cuando el Catch detecta el error(en este caso la variable no declarada) todo el codigo que esta debajo de ese
     error no se lee directamente. Por ejemplo si ponemos la variable debajo de 'Segundo mensaje en el try' el 
     codigo que se imprime en la consola seria diferente:
     -En el Try se agrega el codigo a evaluar
     -Segundo mensaje en el try
     -Catch, captura cualquier surgido en el try
     -Reference error: noExiste is not defined...
     -El bloque finally se ejecutara siempre al final de unbloque try-catch

     Primero se imprimen los dos console.log, luego se imprime el catch q encontro un error, luego se imprime
     que error encontro y finalmente se imprime el finally.




     try {
       let numero = "y";

       if (isNaN(numero)) {
         throw new Error("El caract茅r introducido no es un N煤mero");
       }

       console.log(numero * numero);
     } catch (error) {
       console.log(`Se produjo el siguiente error: ${error}`);
     } 
     
     En este caso lo que hacemos es comprobar que una variable tenga el tipo de dato numero, para que haga imprima
     numero*numero. Con isNaN verificamos que lo que le pasamos por parentesis sea un numero, si es un numero devuelve true si no es un numero devuelve false, en este caso podemos personalizar que nos va a salir en caso de que
     numero no sea un numero(personalizamos lo que va salir en el catch), ponemos la palabra reservada throw new 
     seguida del tipo de error(error de sintaxis, error semantico, etc) si no sabemos que tipo de error vamos a 
     utilizar simplemente defino un error general que seria Error, entonces quedaria : throw new Error + el mensaje que queremos pasarle en la consola al usuario para que sepa el error que esta cometiendo. En este caso le estamos 
     pidiendo el tipo de dato numero. Si la variable numero= 10, en la consola me va imprimir 10*10=100, no marca 
     errores porque 10 efectivamente en un numero. Pero como numero='y' es una string, la cual no cumple la condicion
     y directamente catch me toma el error, por lo cual me va imprimir:
     Se produjo el siguiente error: El caracter introducido no es un Numero.
     
     
     */


    /* **********     Curso JavaScript: 17. break & continue - #jonmircha     ********** */

    /*
    BREAK Y CONTINUE -> nos ayudan a controlar el flujo de nuestras estructuras de control, por ejemplo cuando
    necesitamos romper,saltar o salirnos de la estructura, etc.
    
    const numeros = [0, 1, 2, 3, 4, 5, 16, 7, 8, 9, 0];

    for (let i = 0; i < numeros.length; i++) {       
      if (i === 5) {          
        break;
      }
      console.log(numeros[i]);
    }
    
    En el ejemplo del break quiere decir que recorriendo el array numeros, cuando se cumpla la condicion se salga 
    del for. En este caso lo que hace es cuando se cumpla i=5 (o sea cuando i llege a la posicion 5), se salga
    del for, o sea se sale, se rompe la estructura en la que esta(el for). Lo que se va imprimir es: 0,1,2,3,4


    for (let i = 0; i < numeros.length; i++) {
      if (i === 6) {
        continue;
      }
      console.log(numeros[i]);
    } 
    
    
    En el ejemplo del continue, recorre el array numeros y cuando i este en la posicion 6(i=6) salta la 
    posicion 5. Lo que se va imprimir es 0,1,2,3,4,5,7,8,9,0 (la posicion 6=16 no se va a imprimir, porque la 
    salteo, la omito)
    
    */


    /* **********     Curso JavaScript: 18. Destructuraci贸n - #jonmircha     ********** */
    /*
    DESTRUCTURACION: es una nueva forma(ES6) de asignar valores sobre todo a arreglos y a objetos
    
    Vamos a verlo con arreglos: vamos a suponer que tengo un arreglo, y quiero guardar cada uno de los elementos
    en diferentes variables. Tenemos dos maneras de hacer sin destructuracion y con destructuracion.
    
    const numeros = [1, 2, 3];

    Aca lo que hacemos es guardar en variables independientes cada uno de los elementos del arreglo numeros
    //Sin destructuraci贸n
    let uno = numeros[0],
      dos = numeros[1],
      tres = numeros[2];

    console.log(uno, dos, tres);     //1 2 3

    Aca lo que hacemos es crear un arreglo[one, two, three], al cual le voy asignar el arreglo de numeros.
    Lo que estoy haciendo es que yo se que numeros es un arreglo, entonces a cada una una de las
    posiciones de ese arreglo las estoy guardando dinamicamente dentro de esas variables one,two, three
    //Con destructuraci贸n
    const [one, two, three] = numeros;
    console.log(one, two, three);     //1 2 3 

    Vamos a verlo con objetos:

    Tenemos un objeto para destructurar:

    const persona = {
      nombre: "Jon",
      apellido: "MirCha",
      edad: 35
    };

    Aca es lo mismo que hicimos con arreglos. Creamos un objeto, dentro de ese objeto van a ir variables y le voy
    asignar las propiedades que esten asignadas al objeto persona. De esta forma logramos la destructuracion(o sea
    guardamos los valores de las propiedades del objeto persona en diferentes variables). En la destructuracion
    de objetos ES IMPORTANTE que la variable se llame IGUAL que la propiedad a la cual pretendo aislar en una sola
    variable.

    let { nombre, apellido, edad } = persona;
    console.log(nombre, apellido, edad);    // Jon MirCha 25

    Vamos con el mismo ejemplo pero cambiando el orden de las variables(edad por apellido). En este caso no pasa nada
    si invertimos las variables ya que dentro del objeto busca una propiedad que se llame igual que la varible y le 
    asigna dicho valor.

    let { nombre, edad, apellido } = persona;
    console.log(nombre, apellido, edad);
    
     */


    /* **********     Curso JavaScript: 19. Objetos literales - #jonmircha     ********** */
    /* 
    OBJETOS LITERALES -> una nueva forma de escribir atributos y metodos, incluso de asignarlos.
    

    Aca lo que hacemos es crear dos variables: nombre y edad
    let nombre = "kEnAi",
      edad = 7;

    Aca lo que hacemos es crear un objeto al cual le estoy asignando la propiedad nombre, y a esa propiedad nombre
    le estoy asignando como valor la variable nombre. Le asigno la propiedad edad, a la cual le voy asignar como
    su valor la variable edad. Y ademas tiene una funcion. ESTO ES SIN ES6

    const perro = {
      nombre: nombre,
      edad: edad,
      ladrar: function () {
        console.log("guauu guauu!!!")
      }
    }

    console.log(perro);   //{nombre: kEnAi, edad: 7, ladrar:f }
    perro.ladrar()        //guauu guauu!!!


    Gracias a la nueva actualizacion, ES6, JS lo que hace es "ahorrar" la escritura, es decir, yo creo un objeto
    el cual le voy asignar una propidad que se llame nombre y el valor de esa propiedad es igual a la variable que
    cree mas arriba que se llama nombre, entonces JS entiende que nombre: nombre y podemos directamente poner el 
    nombre de la propiedad y la coma. Como es en el caso de nombre y edad. Si quiero crear otra propiedad y colocar
    el valor lo hago perfectamente como es el caso de la propiedad raza. 
    Tambien cambian los metodos: directamente ponemos el nombre de la propiedad mas los corchetes, el cual indica
    que esa propiedad es un metodo, y abro llaves. Como ejemplo ladrar (){ cod a ejecutar }. En resumen para los
    metodos, saco los dos puntos, saco la palabra reservada function y lo demas queda igual.

    const dog = {
      nombre,
      edad,
      raza: "Callejero",
      ladrar() {
        console.log("guauu guauu guauu!!!")
      }
    }

    console.log(dog);    //{nombre: kEnAi, edad: 7, raza:"Callejero", ladrar: f}
    dog.ladrar();        //guauu guauu guauu
    
    */


    /* **********     Curso JavaScript: 20. Par谩metros REST & Operador Spread - #jonmircha     ********** */
    /* 
    REST: son una forma de virtualmente ir agregando parametros infinitos(ya sea a funcion o dentro de una variable)
    Por ejemplo imaginemos que tenemos un arreglo, donde tenemos valores infinitos. Para hacer esto anteponemos
    tres puntos.


    Aca tenemos una funcion el cual tiene tres parametros, el terecer parametro viene acompa帽ada con el REST(tres
    puntos), eso significa que puede recibir tres, cuatro o cinco parametros por eso ponemos REST.Todo lo que llegue
    despues con C lo voy a tratar como un arreglo, por lo tanto le aplico el metodo forEach para recorrer el array 
    e ir guardando cada elemento en n, una vez guardado en n, lo sumo a resultado y finalmente devuelve resultado.
    
    function sumar(a, b, ...c) {
      let resultado = a + b;

      c.forEach(function (n) {          
        resultado += n
      });

      return resultado;
    }

    console.log(sumar(1, 2));    //3
    console.log(sumar(1, 2, 3));   //6
    console.log(sumar(1, 2, 3, 4));  //10
    console.log(sumar(1, 2, 3, 4, 5));  //15
    console.log(sumar(1, 2, 3, 4, 5, 6));  //21
    console.log(sumar(1, 2, 3, 4, 5, 6, 7));  //28


    OPERADOR SPREAD: nos va permitir que cuando una expresion la tengamos que expandir en situaciones donde tengamos
    que guardar o almacenar multiples argumentos o elementos, lo podamos hacer. Se puede ejecutar en cualquier
    sentencia de nuestro codigo.


    Tenemos un arreglo arr1, y a su vez tenemos otro arreglo arr2. Y a partir de esos dos arreglos yo tengo que 
    crear un tercer arreglo que contengan estos dos arreglos(arr3). Si yo pongo arr3=[arr1,arr2] me va a salir el
    arreglo como un arreglo que contiene dos elementos que son dos arreglos, y como lo que yo quiero es tener un 
    solo arreglo que contenga los elementos del arr1 y arr2. Para eso utilizo el operador spread, utlizo los tres 
    puntos anteponiendolo antes de los nombres del arreglo. Entonces como resultado final, tengo un arreglo con
    los elementos de los arreglos arr1 y arr2, un arreglo con 10 elementos(o posiciones)

    const arr1 = [1, 2, 3, 4, 5],
      arr2 = [6, 7, 8, 9, 0];

    console.log(arr1, arr2);  //[1,2,3,4,5] [6,7,8,9,0]

    const arr3 = [...arr1, ...arr2];
    console.log(arr3);       //[1,2,3,4,5,6,7,8,9,0]
    */   


    /* **********     Curso JavaScript: 21. Arrow Functions - #jonmircha     ********** */
    /*
    Una arrow function basicamente, es como una funcion anonima o expresa, le quitamos la palabra function, y 
    despues de los corchetes le colocamos un igual y mayor que(=>). Cuando la funcion tiene una sola linea de 
    instruccion puedo OMITIR LAS llaves y dejar la funcion flecha en una sola linea de codigo
    
     const saludar = () => console.log(`Hola`);
    saludar();  //Hola 


    PARAMETROS: Cuando una funcion flecha no recibe parametros o recibe mas de un parametro obligatoriamente tengo
    que colocar los corchetes (como el ejemplo anterior o como en el ejemplo de simar), en cambio cuando una funcion
    flecha recibe argumentos o parametros no es necesario colocar los parentesis(como el ejemplo de abajo) 

     /* const saludar = nombre => console.log(`Hola ${nombre}`);
    saludar("Irma");  //Hola Irma
    
    
    Como nos evitamos escribir la palabra function, tambien nos podemos evitar escribir la palabra return. En el 
    ejemplo de la funcion anonima(la primera) creamos una variable sumar en donde voy a guardar la funcion que
    recibe dos parametros(a,b) y eso me retorna la suma de a y b. En cambio en la arrow function directamente
    creo la varible le pongo los dos parametros, coloco los signos => y en vez de poner el return directamente
    coloco a + b.
    
    const sumar = function (a, b) {
      return a + b;
    } 
    const sumar = (a, b) => a + b;

    console.log(sumar(9, 9));   //18
    
    
    En los ejemplos anteriores tuvimos funciones de una sola linea, veamos ahora funciones de varias lineas. En
    los casos donde teniamos una sola linea no era necesario abrir y cerrar llaves para colocar el codigo que va
    a ejecutarse, en cambio si tenemos varias lineas de codigos a ejecutarse es necesario colocar estas llaves,
    los codigos van separados por punto y coma.
    
     const funcionDeVariasLineas = () => {
       console.log("Uno");
       console.log("Dos");
       console.log("Tres");
     }

     funcionDeVariasLineas();   //Uno  Dos  Tres

     Las arrow function tambien sirven para los arreglos. Tenemos un arreglo llamada numeros, y tenemos que iterar
     sobre cada uno de los elementos de ese arreglo para imprimirlos en pantalla, para eso sabemos que tenemos
     el metodo forEach el cual recibe una funcion y esa funcion recibe como parametro el elemento que esta recorriendo el arreglo y la posicion.

    const numeros = [1, 2, 3, 4, 5];

    Ejemplo sin arrow function:

    numeros.forEach(function (el, index){
      console.log(`${el} esta en la posici贸n ${index}`)}
      );

    Ejemplo con arrow function(me queda en una sola linea de codigo, como tiene dos parametros utilizo los corchetes
    como es una sola linea de codigo no necesito utilizar las llaves y asi queda mas prolijo)

    numeros.forEach((el, index) => console.log(`${el} esta en la posici贸n ${index}`));

    // 1 esta en la posici贸n 0
       2 esta en la posici贸n 1
       3 esta en la posici贸n 2
       4 esta en la posici贸n 3
       5 esta en la posici贸n 4
    

    OTROS EJEMPLOS DE ARROW FUNCTION
      
    En esta funcion el this apunta al objeto global(que en google seria el window)
    function Perro() {
      console.log(this);
      }

      Perro(); //window
        
    En este objeto el this apunta al objeto perro
    const perro={
      nombre: "kenai",
      ladrar: function(){
        console.log(this)
      }
    }
    perro.ladrar();   //{nombre:kenai , ladrar:f}

    Si al objeto le cambio el metodo ladrar por una funcion flecha, el objeto this apuntaria al objeto global
     const perro = {
      nombre: "kenai",
      ladrar() => {
        console.log(this)
        }
      }

    perro.ladrar();  //window

    Las arrow function tienen la capacidad de saltarse el contexto en el que estan(en este caso el objeto) y heredar
    o reconocer el contexto en donde se encuentra su objeto padre en el que ha sido declarada. Por eso no es buena
    practica crear un metodo atraves de un arrow function en los objetos. 
    
    En el ejemplo de abajo utilizamos el metodo con la nueva actualizacion(sacando la palabra function ysacando los
    dos puntos), esa es la nueva forma de expresar los metodos en los objetos literales que si reconoce el contexto
    de donde se encuentra

    const perro = {
      nombre: "kenai",
      ladrar() {
        console.log(this)
        }
      }

      perro.ladrar(); //{nombre:kenai , ladrar:f}
    
     */





    /* **********     Curso JavaScript: 22. Prototipos - #jonmircha      ********** */
    // POO
    /*  
    Dentro de la programacion orientada a objeto(POO) hay cuatro conceptos muy importantes:
    Clases - Son un modelo a seguir.
    Objetos - Es una instancia de una clase, tiene dos caracteristicas atributos y metodos:
      Atributos - es una caracter铆stica o propiedad del objeto (son variables dentro de un objeto)
      M茅todos - son las acciones que un objeto puede realizar (son funciones dentro de un objeto)
     
    Vamos a un ejemplo. En este caso vamos a crear dos objetos, animal y animal2(los dos objetos crean un prototipo 
    de objeto). Los dos objetos son muy similares entre si, pero para hacerlos tuve que copiar el mismo codigo con 
    diferentes valores, y esto NO ES FUNCIONAL. Para eso , POO, tenemos las clases. Las clases son un modelo a seguir del cual podemos crear varios objetos.

    
      const animal = {
      nombre: "Snoopy",
      sonar() {
        console.log("Hago sonidos por que estoy vivo");
      }
    }

    const animal2 = {
      nombre: "Lola Bunny",
      sonar() {
        console.log("Hago sonidos por que estoy vivo");
      }
    }

    console.log(animal);   //{nombre: 'Snoopy' , sonar:f}
    console.log(animal2);   //{nombre: 'Lola Bunny' , sonar:f}


    Lo que vamos hacer es crear una FUNCION CONSTRUCTORA, como su nombre lo dice lo voy a construir una sola vez y
    a partir de ella voy a generar nuevas instancias, nuevos objetos, que sean de este tipo de funcion constructora.
    Una funcion en si genera una prototipo vacio. En las clases, en estas funciones la inicial siempre va ir en 
    MAYUSCULA

    //Funci贸n constructora
         function Animal(nombre, genero) {
          //Atributos
          this.nombre = nombre;
          this.genero = genero;

          //M茅todos(no vamos a utilizar arrow functions ni la nueva forma de hacer, sino q utlizamos la de siempre)
          this.sonar = function () {
            console.log("Hago sonidos por que estoy vivo");
          }

          this.saludar = function () {
            console.log(`Hola me llamo ${this.nombre}`);
          }
        } 

        Con la forma de abajo, con el new, logramos crear dos objetos:

      const snoopy = new Animal ('Snoopy' , 'Macho'),
         lolaBunny= new Animal ('Lola Bunny' , 'Hembra');

        Si observamos en la consola, ese animal que creamos, su prototipo es objeto, su constructor es esa
        funcion constructura que esta arriba(Animal)

      console.log(snoopy);  //{nombre: 'Snoopy' , genero: 'Macho' , sonar:f}
      console.log(lolaBunny);   //{nombre: 'Lola Bunny' , genero: 'Hembra' , sonar:f}


      snoopy.sonar(); // Hago sonidos porque estoy vivo
      snoopy.saludar(); // Hola me llamo Snoopy

      lolaBunny.sonar(); // Hago sonidos porque estoy vivo
      lolaBunny.salunar(); // Hola me llamo Lola Bunny

    
    Cuando nosotros creamos funciones constructoras de las cuales pretendemos crear prototipos para JS en la 
    programacion orientada a objeto lo ideal es que nuestras funciones constructoras solamente tengan los atributos
    y saquemos los metodos de la funcion y se los peguemos al prototipo.Entonces finalmente apareceria en el 
    prototipo el prototipo objeto, el metodo saludar y sonar, y la funcion constructora Ejemplo:


    //Funci贸n constructora donde asignamos los m茅todos al Prototipo, no a la funci贸n como tal
      function Animal(nombre, genero) {
       //Atributos
       this.nombre = nombre;
       this.genero = genero;
     } 

     Asignando prototipos: mandamos a llamar el nombre de la funcion constructora(Animal) ponemos un punto, luego
     ponemos la palabra reservada prototype, colocamos otro punto, y finalmente colocamos el nombre del metodo.Ponemos 
     el igual y seguido colocamos la funcion. Con esto asignamos por fuera al prototipo. Lo que va hacer es que cada vez
     que nosotros generemos una nueva variable de tipo animal, la funcion nos va a tener la asignacion de los atributos
     y los metodos van a quedar solamente a ese prototipo Animal, eso va a mejorar el rendimiento y el espacio en 
     memoria.

    //M茅todos agregados al prototipo de la funci贸n constructora
     Animal.prototype.sonar = function () {
      console.log("Hago sonidos por que estoy vivo");
    }

    Animal.prototype.saludar = function () {
      console.log(`Hola me llamo ${this.nombre}`);
    } 

    snoopy.sonar(); // Hago sonidos porque estoy vivo
    snoopy.saludar(); // Hola me llamo Snoopy

    lolaBunny.sonar(); // Hago sonidos porque estoy vivo
    lolaBunny.salunar(); // Hola me llamo Lola Bunny
    */

    /* **********     Curso JavaScript: 23. Herencia - #jonmircha      ********** */

    /* 

    Para el ejemplo de herencia voy a utilizar la funcion constructora Animal, la misma q utilizamos anteriormente

    function Animal(nombre, genero) {
       //Atributos
       this.nombre = nombre;
       this.genero = genero;
     } 


    //Herencia Protot铆pica- Capacidad de poder heredar caracteristicas de un padre a un hijo
     function Perro(nombre, genero, tamanio) {
      this.super = Animal;       //le estoy diciendo que su elemento padre va ser Animal
      this.super(nombre, genero);     //como super es la funcion constructora Animal, recibe los parametros del mismo
      this.tamanio = tamanio;         //le agregue un atributo adicional que no esta en la funcion constructora padre
    } 

    En this.super lo que hago es hacer la 'invocacion' de la funcion constructora Animal,pero realmente donde voy
    hacer la herencia es aca abajo. Voy asignar al prototipo de perro que sea una instancia de Animal
    //Perro est谩 heredando de Animal
     
    Perro.prototype = new Animal();   //esta linea es la que esta haciendo la herencia


    Perro.prototype.constructor = Perro;    //aca lo que hago(puedo hacer) es generarle su propio constructor, a la 
     funcion constructora perro


     Como perro hereda todo lo de Animal puede utilizar sus respectivos metodos, osea los metodos de salunar y sonar, e 
     incluso puede generar nuevos metodos. Tambien podemos hacer una sobreescritura de los metodos del prototipo
     padre en el hijo

    //Sobreescritura de m茅todos del Prototipo padre en el hijo

     Perro.prototype.sonar = function () {   //al prototipo de perro vamos a sobreescribir el metodo sonar
      console.log("Soy un perro y mi sonido es un ladrido");     
    }

    Perro.prototype.ladrar = function () {    //al prototipo de perro le creamos un nuevo metodo
      console.log("Guauuu Guauuu !!!!");
    } 

     const snoopy = new Perro("Snoopy", "Macho", "Mediano")   


    console.log(snoopy); //aca su prototipo es esa funcion constructora de la cual hereda, es decir su prototipo es 
    Animal(el prototipo de animal era Objeto)
    

    snoopy.sonar();   //Soy un perro y mi sonido es un ladrido
    snoopy.saludar(); //Hola me llamo Snoopy
    snoopy.ladrar();  //Guauuu Guauuu !!!

   */





    /* **********     Curso JavaScript: 24. Clases - #jonmircha y Curso JavaScript: 25. M茅todos est谩ticos, getters y setters - #jonmircha     ********** */
    /*
    Vamos a copiar la funcion costructora de Animal(la que tiene los metodos adentro de la funcion), en ves de poner 
    function pongo class.Las clases no llevan argumento. Lo que si llevan es un metodo especial llamado constructor y 
    es el que recibe dichos parametros.
    Los metodos se ponen como las caracteristicas nuevas de los objetos literales, seria el nombre del metodo y
    los parentesis, en caso de ser necesario pueden recibir parametros.
    Las clases simplifican la escritura. Las clases son un prototipo de object. Aunque pongamos los metodos dentro
    del constructor, los metodos aparecen dentro del prototipo(no es necesario agregar los metodos con   
    Animal.prototype.saludar
    
    
     class Animal {
      //el constructor es un m茅todo especial que se ejecuta en el momento de instanciar la clase
      constructor(nombre, genero) {
        this.nombre = nombre;
        this.genero = genero;
      }
      //M茅todos
      sonar() {
        console.log("Hago sonidos por que estoy vivo");
      }

      saludar() {
        console.log(`Hola me llamo ${this.nombre}`);
      }
    }

      const mimi= new Animal ('Mimi' , 'hembra'),
        scooby= new Animal ('Scooby' , 'macho')

      console.log(mimi);  //Animal{nombre: 'Mimi', genero: 'hembra'}
      mimi.sonar();    //Hago sonidos por que estoy vivo
      mimi.salunar();   //Hola me llamo Mimi
      console.log(scooby);   // Animal{nombre: 'Scooby', genero: 'macho'}
      scooby.sonar();   //Hago sonidos por que estoy vivo
      scooby.saludar();   //Hola me llamo Scooby

    Herencia: a la clase perro le vamos a decir que herede el prototipo Animal con una palabra reservada que se llama
    extends. En el constructor ponemos los tres parametros: nombre, genero, tamanio. Y ahi mando a llamar a super.
    En el anterior ejemplo, de herencia, a super lo ponia como this.super; en este caso no es necesario. Dentrp de
    super ponemos los parametros de nombre y de genero(que vienen del padre, Animal) mientras tanto tamanio es un
    propiedad excusiva de Perro por eso la defino dentro del constructor de perro pero fuera de la invocacion de super

    class Perro extends Animal {
      constructor(nombre, genero, tamanio) {
        //con el m茅todo super() se manda a llamar el constructor de la clase padre
        super(nombre, genero);
        this.tamanio = tamanio;
        this.raza = null;
      }
      //sobreescribi el metodo sonar
      sonar() {
        console.log("Soy un perro y mi sonido es un ladrido");
      }
      
      //genere un nuevo metodo ladrar
      ladrar() {
        console.log("Guauuu Guauuu!!!");
      }


      const scooby= new Perro ('Scooby' , 'macho' , 'gigante')

      console.log(scooby);   // Animal{nombre: 'Scooby', genero: 'macho' , tamanio: 'gigante'}
      scooby.sonar();   //Soy un perro y mi sonido es un ladrido
      scooby.saludar();   //Hola me llamo
      scooby.ladrar();   //Guauuu Guauuu!!!

      Entonces, perro tiene su propiedad nombre, genero y tamanio. Deriva del prototipo animal. El constructor es
      la clase Perro, y tiene el metodo sobreescrito sonar, tiene el nuevo metodo ladrar. 
      Perro deriva de Animal y animal deriva de object, y ese Object titne el sonar original de la clase Animal, y 
      tiene el metodo saludar. Aunque el metodo saludar no este en Perro, pero como en el prototipo perro si existe 
      ese metodo, entonces Perro la puede utilizar.


      
      //un m茅todo est谩tico es aquel que se pueden ejecutar sin necesidad de instanciar la clase. Para que un
      metedo se vuelva estatico, al metodo le anteponemos la palabra static. Por lo tanto este es un metodo que
      puedo ejecutarlo sin la necesidad de hbaer creado un objeto del tipo que pertenece la clase. Entonces 
      directamente invoco el nombre de la clase (Perro.queEres();)

      static queEres() {
        console.log("Los perros somos animales mam铆feros que pertenecemos a la familia de los caninos. Somos considerados los mejores amigos del hombre.");
      }
      
       Perro.queEres(); //Los perro somos animales mamiferos que pertenecemos a la familia de los caninos. Somos
       considerados los mejores amigos del hombre.

      //Los setters y getters son m茅todos especiales que nos permiten establecer y obtener los valores de atributos de 
      nuestra clase. Aca creamos un nuevo metodo, el cual queremos obtener el valor de raza de la clase Perro.
      Para detectar que son metodos obtenedores y establecedores se le antepone el verbo. En este casi quedaria 
      getRaza. Un metodo obtenedor va retornar el valor de la propiedad en cuestion que seria this.raza.
      Para indicarle dentro de la clase que no es un simple metodo, sino que es un tipo de metodo obtenedor le 
      anteponemos la palabra get y quedaria get getRaza(){}.
      Para generar un metodo establecedor que modifique el valor de dicha propiedad definimos set, de igual manera
      se acostumbra a anteponer el verbo entonces quedaria set setRaza. Como vamos a establecer un nuevo valor 
      significa que va estar esperando un valor en el parametro que podria ser la raza que queremos modificar.
      Y dentro de las llaves seria: a la propiedad raza asignarle el valor raza que esta recibiendo en el parametro.

      get getRaza() {
        return this.raza;
      }

      set setRaza(raza) {
        this.raza = raza;
      }
    }

    const mimi = new Animal("Mimi", "Hembra"),
      scooby = new Perro("Scooby", "Macho", "Gigante");
    
    Para imprimir el valor vamos a tener que hacer un console.log, lo vamos a tratar como si fuera un atributo y
    no como un metodo
    
    console.log(scooby.getRaza);       //null
    scooby.setRaza = "Gr谩n Dan茅s";     //se trabaja como si fuera una propiedad, no como un metodo-> scooby.setRaza('')
    console.log(scooby.getRaza);       //Gran Danes       
    .                                    se trabaja como si fuera una un atributo y no como un metodo->scooby.getRaza()
    */  





    /* **********     Curso JavaScript: 26. Objeto console - #jonmircha     ********** */
    /* console.log(console);   //marca los metodos para console
    console.error("Esto es un error");  //da un mensaje como si fuera un error, se pinta en rojo
    console.warn("Esto es un aviso");   //da avisos, se pinta en amarillo
    console.info("Esto es un mensje informativo");   //mensaje informativo 
    console.log("Un registro de lo que ha pasado en nuestra aplicaci贸n");

    let nombre = "Jon",
      apellido = "MirCha",
      edad = 35;

    console.log(nombre);  //Jon
    console.log(apellido);  //MirCha
    console.log(edad);   //35
    console.log(nombre, apellido, edad);   //Jon MirCha 35
    console.log(`Hola mi nombre es ${nombre} ${apellido} y tengo ${edad} a帽os.`); //Hola mi nombre es Jon Mircha y 
    tengo 35 a帽os
    console.log(`Hola mi nombre es %s %s y tengo %d a帽os.`, nombre, apellido, edad); //Hola mi nombre es Jon MirCha y 
    tengo 35 a帽os (%s significa string y %d significa digitos, luego ponemos con que reemplazamos esos signos)
    console.clear();   //limpia todo lo que esta en la consola
    console.log(window);  //las propiedades del objeto global window
    console.log(document);  //document es la representacion del documento HTML a treves de JS, me muestra el archivo 
    literalmente de HTML
    console.dir(window); //cuando queremos ver el window representado como un objeto que podamos parsear o analizar
    para saber todas las caracteristicas, metodos, atributos que tiene en JS
    console.dir(document);  //uando queremos ver el document representado como un objeto que podamos parsear o analizar
    para saber todas las caracteristicas, metodos, atributos que tiene en JS

    console.group("Cursos de @jonmircha en YouTube");
    console.log("Curso de JavaScript");
    console.log("Curso de Node.js");
    console.log("Curso de PWAs");
    console.log("Curso de Flexbox");
    console.log("Curso de Dise帽o y Programaci贸n Web");
    console.groupEnd();

    console.groupCollapsed("Cursos de @jonmircha en YouTube");   //para agrupar, coloco los console.log abajo
    console.log("Curso de JavaScript");
    console.log("Curso de Node.js");
    console.log("Curso de PWAs");
    console.log("Curso de Flexbox");
    console.log("Curso de Dise帽o y Programaci贸n Web");
    console.groupEnd();  // y finalizo la agrupacion
    
    console.log(console);
    console.table(Object.entries(console).sort());   //podemos hacer tablitas, por ejemplo todo lo que estaba en
    en cosole.log(console) que lo represente en una tabla y el sort lo puedo colocar o no, es para que este ordenado 
    alfabeticamente

    const numeros = [1, 2, 3, 4, 5],
      vocales = ["a", "e", "i", "o", "u"];

    console.table(numeros);
    console.table(vocales);

    const perro = {
      nombre: "Boni",
      raza: "Boxer",
      color: "cafe"
    }
    console.table(perro);

    console.time('Cuanto tiempo tarda mi c贸digo');  //para saber cuanto tiempo tarda mi codigo, inicio
    const arreglo = Array(1000000);

    for (let i = 0; i < arreglo.length; i++) {
      arreglo[i] = i;
    }

    console.timeEnd('Cuanto tiempo tarda mi c贸digo');  //para ver cuanto tarda mi codigo, final


    for (let i = 0; i <= 100; i++) {
      console.count("c贸digo for");    //coloca en consola las vueltas del for, osea coloca si fue la primera o ultima  vez que se ejecuta el codigo
      console.log(i);
    }


    let x = 3,
      y = 2,
      pruebaXY = "Se espera que X siempre sea menor que Y";

    console.assert(x < y, { x, y, pruebaXY });   //como para hacer pruebas, pongo el assert, pongo la condicion,
    pongo la x, y, el mensaje(pruebaXY). Si se cumple la condicion, no sale nada, en cambio si  no se cumple sale
    el assertion failed
    */





    /* **********     Curso JavaScript: 27. Objeto Date - #jonmircha     ********** */
    /* console.log(Date());  //me aparece el nombre del dia, el mes, el numero del dia, el a帽os y la hora(hh,mm,ss) y 
    GTM - ..(uso horario)

    let fecha = new Date();  //guardo el date
    console.log(fecha);   //aparece lo mismo que al principio

    //d铆a del mes
    console.log(fecha.getDate()); //aparece el numero del dia

    //d铆a de la semana D L M Mi J V S -> 0 1 2 3 4 5 6
    console.log(fecha.getDay());   //jueves ->4 , me aparece el numero que representa el dia

    //mes Ene Feb Mar Abr May Jun Jul Ago Sep Oct Nov Dic -> 0 1 2 3 4 5 6 7 8 9 10 11
    console.log(fecha.getMonth());  //me parece el numero
    console.log(fecha.getFullYear());  //me aparece el a帽o
    console.log(fecha.getHours());  //hora, formato de 00 a 23 horas
    console.log(fecha.getMinutes());  //minutos, formato
    console.log(fecha.getSeconds());  //segundos
    console.log(fecha.getMilliseconds());  //milisegundos
    console.log(fecha.toString());  //me da la fecha igual q las primeras dos
    console.log(fecha.toDateString());  //me da la fecha nombre del diaa, mes, numero de dia y a帽o
    console.log(fecha.toLocaleString()); //me aparece de la forma dd/mm/aaa hh:mm:ss
    console.log(fecha.toLocaleDateString()); //si solo quisieramos la parte de la fecha dd/mm/aaaa
    console.log(fecha.toLocaleTimeString()); //si solo quisieramos la parte de la hora hh:mm:ss
    console.log(fecha.getTimezoneOffset());  //me aparece el uso horario(basado en minutos)
    console.log(fecha.getUTCDate());   //me dice el dia que es en el uso horario 0
    console.log(fecha.getUTCHours());  //me dice la hora que es en el uso horario 0
    console.log(Date.now());   //sale un numero largo, y significa cuantos segundos pasaron desde el 1ero de enero 1970

    let cumpleJon = new Date(1984, 4, 23);   //para guardar una fecha
    console.log(cumpleJon); 
    */





    /* **********     Curso JavaScript: 28. Objeto Math - #jonmircha     ********** */
    /* console.log(Math);
    console.log(Math.PI);   //para imprimir el PI
    console.log(Math.abs(-7.8));    //te devuelve el numero absoluto de un numero
    console.log(Math.ceil(7.2));   //redondea el numero entero posterior inmediato, 8
    console.log(Math.floor(7.8));  //redondea al numero entero menor inmediato, 7
    console.log(Math.round(7.49));  //redondea al mas cercano inmediato, 7
    console.log(Math.sqrt(81));  //sacar la raiz cuadrada de un numero, 9
    console.log(Math.pow(2, 5));  //exponer un numero, el primero es la base y el segundo es el exponente, 32
    console.log(Math.sign(-0.3)); // -1 0 1   sign me va indicar si el valor es positivo negativo o cero, -1
    console.log(Math.random());  //me va a dar un valor aleatorio entre 0 y 1, si quiero cambiar por ej entre o y 1000 tengo que colocar Math.random()*1000   -> asi logramos q sea un numero aleatorio entre 0 y 1000
    console.log(Math.round(Math.random() * 1000)); // 
    */





    /* **********     Curso JavaScript: 29. Operador de Cortocircuito - #jonmircha     ********** */
    /*    
    function saludar(nombre) {
       nombre = nombre || "Desconocido";  //si no le pasamos el parametro, aplicamos el nombre Desconocido
       console.log(`Hola ${nombre}`);
     }

     saludar("Jon");   //Hola Jon
     saludar();   //Hola Desconocido
     
     Cortocircuito OR - cuando el valor de la izquierda en la expresi贸n siempre pueda validar a true, es el valor que se cargar谩 por defecto

     Valores que tienden a verdadero
     console.log("cadena" || "Valor de la derecha");  //cadena
     console.log(19 || "Valor de la derecha");   //19
     console.log(true || "Valor de la derecha");  //true
     console.log([] || "Valor de la derecha");  //[]
     console.log({} || "Valor de la derecha");  //{}

     Valores que tienen a false
     console.log(false || "Valor de la derecha");  //Valor de la derecha
     console.log(null || "Valor de la derecha");  //Valor de la derecha
     console.log(undefined || "Valor de la derecha"); //Valor de la derecha
     console.log("" || "Valor de la derecha"); //Valor de la derecha
     console.log(-2 || "Valor de la derecha"); //-2
     console.log(0 || "Valor de la derecha");  //Valor de la derecha

     Cortocircuito AND - cuando el valor de la izquierda en la expresi贸n siempre pueda validar a false, es el valor que se cargar谩 por defecto

     console.log(false && "Valor de la derecha"); //false
     console.log(null && "Valor de la derecha");  //null
     console.log(undefined && "Valor de la derecha"); //undefined
     console.log("" && "Valor de la derecha");  //""
     console.log(-2 && "Valor de la derecha");  //Valor de la derecha
     console.log(0 && "Valor de la derecha");  //0

     console.log("cadena" && "Valor de la derecha");  //Valor de la derecha
     console.log(19 && "Valor de la derecha");   //Valor de la derecha
     console.log(true && "Valor de la derecha");  //Valor de la derecha
     console.log([] && "Valor de la derecha");  //Valor de la derecha
     console.log({} && "Valor de la derecha"); //Valor de la derecha
     */





    /* **********     Curso JavaScript: 30. alert, confirm y prompt - #jonmircha     ********** */
    /*alert, confirm y prompt son metodos para interactuar con el usuario
    console.log(window);
    alert("Hola esto es una alerta"); //me sale un cuadro hola esto es una alerta, con un boton de aceptar
    confirm("Hola esto es una confirmaci贸n"); //me sale un cuadro tambien, pero con dos botones: aceptar,cancelar
    prompt("Hola esto es un aviso y le permite al usuario ingresar un valor"); //sale un cuadro, con los dos botones 
    de aceptar y cancelar pero tambien sale para poder poner algun valor para enviar

     let alerta = alert("Hola esto es una alerta"),
      confirmacion = confirm("Hola esto es una confirmaci贸n"),
      aviso = prompt("Hola esto es un aviso y le permite al usuario ingresar un valor");

    console.log(alerta);   //undefined
    console.log(confirmacion);  //true si pongo aceptar y false si le digo cancelar
    console.log(aviso);  //vacio si le pongo aceptar, devuelve la palabra que escribir si le pongo aceptar y devuelve
    null si escribi algo y puse cancelar
 */





    /* **********     Curso JavaScript: 31. Expresiones Regulares - #jonmircha     ********** */
    /*
     Expresiones Regulares(no es propio de JS)
        Son una secuencia de caracteres que forma un patr贸n de b煤squeda, principalmente utilizada para la b煤squeda de patrones de cadenas de caracteres.

        https://es.wikipedia.org/wiki/Expresi%C3%B3n_regular
        https://developer.mozilla.org/es/docs/Web/JavaScript/Guide/Regular_Expressions
    
      let cadena = "Lorem ipsum dolor sit amet consectetur adipisicing elit. Voluptatem fuga cupiditate dolores saepe, praesentium sit eaque recusandae id sapiente similique, laudantium voluptatum perferendis ea iure ad odio doloremque earum voluptate.";

    Tenemos dos maneras de utilizar la expresion regular:
    La primera opcion, recibe dos parametros: el primer patron que quiero buscar y el segundo parametro es la bandera. 
    Si pusieramos solo la palabra lorem, se detendra a la primera palabra que sea lorem, si en el segundo parametro le 
    ponemos la bandera g, quiere decir que busque todas las coincidencias.En este caso lo ponemos ig, i significa que 
    ignore si la palabra esta en mayuscula o miniscula mientras sea la misma y g significa que busque todas las 
    coincidencias, no solo que vea la primer coincidencia

     let expReg = new RegExp("lorem", "ig");  
     console.log(expReg.test(cadena));  //true
     console.log(expReg.exec(cadena)); //devuelve un arreglo con mas informacion

     La segunda manera de ejecutar una expresion regular, simplemente a la expresion regular la ponemos entre barras, 
     y para agregar las banderas directamente le colocamos la palabra ig(que tienen el mismo significado que el 
     anterior). Despues de lorem hay un {1,} ahi le estoy generando un "rango" en este caso le estoy diciendo que 
     lorem se puede repetir indefinidamente, sino {1,3} con esto le estoy diciendo que lorem se puede repetir del 
     hasta 3

     let expReg2 = /lorem{1,}/ig;
     console.log(expReg2.test(cadena));// true
     console.log(expReg2.exec(cadena)); //devuelve un arreglo con mas informacion
     
     Para que JS valide la expresion regular, utilizamos dos metodos(hay mas metodos): el metodo test y el metodo 
     exec*/





    /* **********     Curso JavaScript: 32. Funciones An贸nimas Autoejecutables - #jonmircha     ********** */
    /*   Funci贸n An贸nima Autoejecutables ->significa que es una funcion en la cual englobamos todo el codigo que 
        queremos ejecutar.Nos van a permitir poder pasar parametros y utilizar alias dentro del cuerpo de nuestra
        funcion

       (function () {
         console.log("Mi primer IIFE");
       })();  //en este si hay que poner punto y coma si o si para separar el codigo

       (function (d, w, c) {
         console.log("Mi segunda IIFE");
         console.log(d);  //Document
         console.log(w);  //window
         c.log("Este es un console.log")  //Este es un console.log
       })(document, window, console);  //estoy pasando el objeto document en la variable d o sea se lo estoy asignando al primer paramtro, window al segundo parametro y finalmente console al tercer parametros


       Formas de escribir las funciones An贸nimas Autoejecutables
       //Cl谩sica ->la misma que la anterior
       (function () {
         console.log('versi贸n Cl谩sica')
       })();

       //La Crockford (JavaScript The Good Parts) ->el mismo formato clasico pero lo unico que cambia es que esta agrupando todo con un parentesis de mas
       ((function () {
         console.log('versi贸n Crockford')
       })());

       //Unaria ->no hay necesidad de encapsular la funcion en un parentesis porque lo reemplazamos por el signo de mas, que lo ayuda a ejecutarse
       +function () {
         console.log('versi贸n Unaria')
       }();

       //Facebook ->empiezo con un signo de exclamacion
       !function () {
         console.log('versi贸n Facebook')
       }(); */
  </script>
</body>

</html>
